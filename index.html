<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Пиксельная Песочница: Пещерный уровень</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Courier New', monospace;
        }
        
        body {
            background: #111;
            color: #eee;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 20px;
            overflow: hidden;
        }
        
        #gameCanvas {
            border: 3px solid #444;
            background: #000;
            display: block;
            box-shadow: 0 0 20px rgba(0, 100, 200, 0.5);
        }
        
        .info {
            margin-top: 20px;
            text-align: center;
            max-width: 800px;
            line-height: 1.5;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #444;
        }
        
        h1 {
            color: #4af;
            margin-bottom: 10px;
            font-size: 28px;
            text-shadow: 0 0 5px #4af;
        }
        
        .controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-top: 15px;
            width: 100%;
        }
        
        .control-group {
            background: rgba(30, 30, 40, 0.7);
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #444;
        }
        
        h2 {
            color: #8cf;
            margin-bottom: 8px;
            font-size: 18px;
        }
        
        ul {
            list-style-type: none;
            padding-left: 10px;
        }
        
        li {
            margin-bottom: 5px;
            color: #ccc;
        }
        
        .key {
            display: inline-block;
            background: #333;
            padding: 2px 6px;
            border-radius: 4px;
            border: 1px solid #555;
            margin: 0 2px;
            font-weight: bold;
        }
        
        .status {
            margin-top: 10px;
            color: #8f8;
            font-weight: bold;
        }
        
        .warning {
            color: #f88;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <h1>ПИКСЕЛЬНАЯ ПЕСОЧНИЦА: ПЕЩЕРЫ</h1>
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    
    <div class="info">
        <div class="controls">
            <div class="control-group">
                <h2>Управление</h2>
                <ul>
                    <li>Движение: <span class="key">W</span><span class="key">A</span><span class="key">S</span><span class="key">D</span> или <span class="key">←↑↓→</span></li>
                    <li>Собрать ресурс: <span class="key">E</span></li>
                    <li>Открыть крафт: <span class="key">C</span></li>
                    <li>Плавить руду у печки: <span class="key">F</span></li>
                    <li>Спуститься/подняться: <span class="key">ПРОБЕЛ</span> у шахты/лестницы</li>
                    <li>Выбрать слот: <span class="key">1</span>-<span class="key">8</span> или колесо мыши</li>
                    <li>Построить/атаковать/инструмент: <span class="key">ЛКМ</span></li>
                    <li>Закрыть меню: <span class="key">ESC</span></li>
                </ul>
            </div>
            <div class="control-group">
                <h2>Новые особенности</h2>
                <ul>
                    <li>Улучшенная кирка выпадает с первого босса</li>
                    <li>Улучшенная кирка ломает алтари (возвращает в инвентарь)</li>
                    <li>Улучшенная кирка копает 3 тайла за раз</li>
                    <li>Скипетр пещерного босса имеет увеличенный урон</li>
                    <li>10% шанс получить алтарь возрождения с зомби</li>
                    <li>Установите алтарь возрождения для точки респавна</li>
                    <li>Информация о боссах удалена из интерфейса</li>
                </ul>
            </div>
        </div>
        <div class="status" id="status">Добро пожаловать! Собирайте ресурсы и создавайте предметы.</div>
    </div>

    <script>
        // ============================
        // КОНСТАНТЫ И НАСТРОЙКИ
        // ============================
        const CANVAS_WIDTH = 800;
        const CANVAS_HEIGHT = 600;
        const TILE_SIZE = 32;
        const WORLD_WIDTH = 50;
        const WORLD_HEIGHT = 40;
        const PLAYER_SIZE = 24;
        const PLAYER_SPEED = 4;
        const BOSS_SIZE = 64;
        const CAVE_BOSS_SIZE = 72;
        const PROJECTILE_SIZE = 20; // Увеличен с 12 до 20
        const PROJECTILE_SPEED = 3;
        const DAY_DURATION = 300000; // 5 минут день
        const NIGHT_DURATION = 180000; // 3 минуты ночь
        const DAYS_FOR_TREE_GROWTH = 2;
        
        // Уровни мира
        const WORLD_LEVELS = {
            SURFACE: 0,
            CAVE: 1
        };
        
        // Время суток
        const TIME_OF_DAY = {
            DAY: 0,
            NIGHT: 1
        };
        
        // Типы тайлов мира (поверхность)
        const TILE_TYPES = {
            GRASS: 0,
            WATER: 1,
            STONE: 2,
            TREE: 3
        };
        
        // Типы тайлов пещеры
        const CAVE_TILE_TYPES = {
            CAVE_WALL: 10,
            CAVE_FLOOR: 11,
            IRON_ORE: 12,
            COAL_ORE: 13,
            CAVE_EXIT: 14  // Лестница на поверхность
        };
        
        // Типы предметов
        const ITEM_TYPES = {
            NONE: 0,
            WOOD: 1,
            STONE: 2,
            PLANK: 3,
            WALL: 4,
            HAMMER: 5,
            ALTAR: 6,
            SHOVEL: 7,
            PICKAXE: 8,
            IRON_ORE: 9,
            COAL: 10,
            IRON_BAR: 11,
            FURNACE: 12,
            MINE_SHAFT: 13,
            LADDER: 14,
            IRON_HAMMER: 15,
            TORCH: 16,
            MAGIC_SCEPTER: 17,
            IMPROVED_PICKAXE: 18, // Новая улучшенная кирка
            RESURRECTION_ALTAR: 19 // Новый алтарь возрождения
        };
        
        // Названия предметов
        const ITEM_NAMES = {
            [ITEM_TYPES.NONE]: "Пусто",
            [ITEM_TYPES.WOOD]: "Дерево",
            [ITEM_TYPES.STONE]: "Камень",
            [ITEM_TYPES.PLANK]: "Доска",
            [ITEM_TYPES.WALL]: "Стена",
            [ITEM_TYPES.HAMMER]: "Молот",
            [ITEM_TYPES.ALTAR]: "Алтарь",
            [ITEM_TYPES.SHOVEL]: "Лопата",
            [ITEM_TYPES.PICKAXE]: "Кирка",
            [ITEM_TYPES.IRON_ORE]: "Железная руда",
            [ITEM_TYPES.COAL]: "Уголь",
            [ITEM_TYPES.IRON_BAR]: "Железный слиток",
            [ITEM_TYPES.FURNACE]: "Печка",
            [ITEM_TYPES.MINE_SHAFT]: "Шахта",
            [ITEM_TYPES.LADDER]: "Лестница",
            [ITEM_TYPES.IRON_HAMMER]: "Железный молот",
            [ITEM_TYPES.TORCH]: "Факел",
            [ITEM_TYPES.MAGIC_SCEPTER]: "Волшебный скипетр",
            [ITEM_TYPES.IMPROVED_PICKAXE]: "Улучшенная кирка",
            [ITEM_TYPES.RESURRECTION_ALTAR]: "Алтарь возрождения"
        };
        
        // Цвета предметов
        const ITEM_COLORS = {
            [ITEM_TYPES.NONE]: "#333",
            [ITEM_TYPES.WOOD]: "#8B4513",
            [ITEM_TYPES.STONE]: "#808080",
            [ITEM_TYPES.PLANK]: "#DEB887",
            [ITEM_TYPES.WALL]: "#696969",
            [ITEM_TYPES.HAMMER]: "#D2691E",
            [ITEM_TYPES.ALTAR]: "#800080",
            [ITEM_TYPES.SHOVEL]: "#A0522D",
            [ITEM_TYPES.PICKAXE]: "#696969",
            [ITEM_TYPES.IRON_ORE]: "#B22222",
            [ITEM_TYPES.COAL]: "#2F4F4F",
            [ITEM_TYPES.IRON_BAR]: "#A9A9A9",
            [ITEM_TYPES.FURNACE]: "#8B0000",
            [ITEM_TYPES.MINE_SHAFT]: "#654321",
            [ITEM_TYPES.LADDER]: "#D2B48C",
            [ITEM_TYPES.IRON_HAMMER]: "#C0C0C0",
            [ITEM_TYPES.TORCH]: "#FFA500",
            [ITEM_TYPES.MAGIC_SCEPTER]: "#9370DB",
            [ITEM_TYPES.IMPROVED_PICKAXE]: "#FFD700", // Золотой цвет для улучшенной кирки
            [ITEM_TYPES.RESURRECTION_ALTAR]: "#00FF00" // Зеленый для алтаря возрождения
        };
        
        // Рецепты крафта
        const RECIPES = [
            {
                id: 0,
                name: "Доска",
                result: ITEM_TYPES.PLANK,
                ingredients: [{type: ITEM_TYPES.WOOD, count: 2}]
            },
            {
                id: 1,
                name: "Молот",
                result: ITEM_TYPES.HAMMER,
                ingredients: [
                    {type: ITEM_TYPES.STONE, count: 1},
                    {type: ITEM_TYPES.PLANK, count: 1}
                ]
            },
            {
                id: 2,
                name: "Стена",
                result: ITEM_TYPES.WALL,
                ingredients: [{type: ITEM_TYPES.STONE, count: 3}]
            },
            {
                id: 3,
                name: "Алтарь",
                result: ITEM_TYPES.ALTAR,
                ingredients: [
                    {type: ITEM_TYPES.STONE, count: 5},
                    {type: ITEM_TYPES.WOOD, count: 3}
                ]
            },
            {
                id: 4,
                name: "Лопата",
                result: ITEM_TYPES.SHOVEL,
                ingredients: [
                    {type: ITEM_TYPES.WOOD, count: 2},
                    {type: ITEM_TYPES.STONE, count: 1}
                ]
            },
            {
                id: 5,
                name: "Кирка",
                result: ITEM_TYPES.PICKAXE,
                ingredients: [{type: ITEM_TYPES.STONE, count: 3}]
            },
            {
                id: 6,
                name: "Печка",
                result: ITEM_TYPES.FURNACE,
                ingredients: [{type: ITEM_TYPES.STONE, count: 5}]
            },
            {
                id: 7,
                name: "Лестница",
                result: ITEM_TYPES.LADDER,
                ingredients: [
                    {type: ITEM_TYPES.WOOD, count: 3},
                    {type: ITEM_TYPES.STONE, count: 1}
                ]
            },
            {
                id: 8,
                name: "Железный молот",
                result: ITEM_TYPES.IRON_HAMMER,
                ingredients: [
                    {type: ITEM_TYPES.IRON_BAR, count: 2},
                    {type: ITEM_TYPES.PLANK, count: 1}
                ]
            },
            {
                id: 9,
                name: "Факел",
                result: ITEM_TYPES.TORCH,
                ingredients: [
                    {type: ITEM_TYPES.PLANK, count: 1},
                    {type: ITEM_TYPES.COAL, count: 1}
                ]
            }
        ];
        
        // ============================
        // КЛАСС ИГРОКА
        // ============================
        class Player {
            constructor() {
                this.x = WORLD_WIDTH * TILE_SIZE / 2;
                this.y = WORLD_HEIGHT * TILE_SIZE / 2;
                this.size = PLAYER_SIZE;
                this.speed = PLAYER_SPEED;
                this.health = 100;
                this.maxHealth = 100;
                this.selectedSlot = 0;
                this.inventory = new Inventory(10);
                this.lastAttackTime = 0;
                this.attackCooldown = 500; // мс
                this.currentLevel = WORLD_LEVELS.SURFACE;
                this.lastSmeltTime = 0;
                this.smeltCooldown = 1000; // мс
                this.isInvulnerable = false;
                this.invulnerabilityTimer = 0;
                this.invulnerabilityDuration = 1000; // мс
                this.lastMagicAttackTime = 0;
                this.magicAttackCooldown = 800; // мс
                this.projectiles = [];
                this.respawnX = WORLD_WIDTH * TILE_SIZE / 2; // Точка возрождения по умолчанию
                this.respawnY = WORLD_HEIGHT * TILE_SIZE / 2;
                this.respawnLevel = WORLD_LEVELS.SURFACE;
            }
            
            update(keys, world, deltaTime, gameTime) {
                let dx = 0, dy = 0;
                
                // Управление игроком
                if (keys['ArrowUp'] || keys['KeyW']) dy -= this.speed;
                if (keys['ArrowDown'] || keys['KeyS']) dy += this.speed;
                if (keys['ArrowLeft'] || keys['KeyA']) dx -= this.speed;
                if (keys['ArrowRight'] || keys['KeyD']) dx += this.speed;
                
                // Нормализация диагонального движения
                if (dx !== 0 && dy !== 0) {
                    dx *= 0.7071; // 1/√2
                    dy *= 0.7071;
                }
                
                // Проверка коллизий по X
                const newX = this.x + dx;
                if (!this.checkCollision(newX, this.y, world)) {
                    this.x = newX;
                }
                
                // Проверка коллизий по Y
                const newY = this.y + dy;
                if (!this.checkCollision(this.x, newY, world)) {
                    this.y = newY;
                }
                
                // Ограничение в пределах мира
                this.x = Math.max(0, Math.min(WORLD_WIDTH * TILE_SIZE - this.size, this.x));
                this.y = Math.max(0, Math.min(WORLD_HEIGHT * TILE_SIZE - this.size, this.y));
                
                // Обновление времени перезарядки атаки
                if (this.lastAttackTime > 0) {
                    this.lastAttackTime -= deltaTime;
                }
                
                // Обновление времени перезарядки магической атаки
                if (this.lastMagicAttackTime > 0) {
                    this.lastMagicAttackTime -= deltaTime;
                }
                
                // Обновление времени перезарядки плавки
                if (this.lastSmeltTime > 0) {
                    this.lastSmeltTime -= deltaTime;
                }
                
                // Обновление неуязвимости
                if (this.isInvulnerable) {
                    this.invulnerabilityTimer -= deltaTime;
                    if (this.invulnerabilityTimer <= 0) {
                        this.isInvulnerable = false;
                    }
                }
                
                // Обновление снарядов игрока (для магического скипетра)
                for (let i = this.projectiles.length - 1; i >= 0; i--) {
                    const projectile = this.projectiles[i];
                    projectile.update(deltaTime);
                    
                    // Проверка столкновений снарядов с врагами
                    if (gameTime.currentTime === TIME_OF_DAY.NIGHT) {
                        if (this.currentLevel === WORLD_LEVELS.SURFACE) {
                            for (let zombie of gameTime.surfaceMobs) {
                                if (zombie.alive && projectile.checkCollision(zombie)) {
                                    zombie.takeDamage(projectile.damage);
                                    projectile.active = false;
                                    break;
                                }
                            }
                        } else if (this.currentLevel === WORLD_LEVELS.CAVE) {
                            for (let skeleton of gameTime.caveMobs) {
                                if (skeleton.alive && projectile.checkCollision(skeleton)) {
                                    skeleton.takeDamage(projectile.damage);
                                    projectile.active = false;
                                    break;
                                }
                            }
                        }
                    }
                    
                    // Проверка столкновений снарядов с боссами
                    if (this.currentLevel === WORLD_LEVELS.SURFACE && game.boss && game.boss.alive) {
                        if (projectile.checkCollision(game.boss)) {
                            game.boss.takeDamage(projectile.damage);
                            projectile.active = false;
                        }
                    }
                    
                    if (this.currentLevel === WORLD_LEVELS.CAVE && game.caveBoss && game.caveBoss.alive) {
                        if (projectile.checkCollision(game.caveBoss)) {
                            game.caveBoss.takeDamage(projectile.damage);
                            projectile.active = false;
                        }
                    }
                    
                    // Удаление неактивных снарядов
                    if (!projectile.active) {
                        this.projectiles.splice(i, 1);
                    }
                }
            }
            
            checkCollision(x, y, world) {
                // Определяем уровень мира для проверки
                const level = this.currentLevel;
                
                // Проверяем коллизии с препятствиями мира
                const left = Math.floor(x / TILE_SIZE);
                const right = Math.floor((x + this.size - 1) / TILE_SIZE);
                const top = Math.floor(y / TILE_SIZE);
                const bottom = Math.floor((y + this.size - 1) / TILE_SIZE);
                
                for (let ty = top; ty <= bottom; ty++) {
                    for (let tx = left; tx <= right; tx++) {
                        if (tx >= 0 && tx < WORLD_WIDTH && ty >= 0 && ty < WORLD_HEIGHT) {
                            if (level === WORLD_LEVELS.SURFACE) {
                                // Проверка коллизий на поверхности
                                const tileType = world.surfaceTiles[ty][tx];
                                // Вода - препятствие
                                if (tileType === TILE_TYPES.WATER) {
                                    return true;
                                }
                                
                                // Проверяем построенные тайлы
                                const placedKey = `${tx},${ty}`;
                                if (world.surfacePlacedTiles.has(placedKey)) {
                                    const placedType = world.surfacePlacedTiles.get(placedKey);
                                    // Шахта не должна быть препятствием - игрок должен стоять на ней для спуска
                                    if (placedType !== ITEM_TYPES.MINE_SHAFT && placedType !== ITEM_TYPES.TORCH) {
                                        return true;
                                    }
                                }
                            } else if (level === WORLD_LEVELS.CAVE) {
                                // Проверка коллизий в пещере
                                const tileType = world.caveTiles[ty][tx];
                                // Стены пещеры и руды - препятствия
                                if (tileType === CAVE_TILE_TYPES.CAVE_WALL || 
                                    tileType === CAVE_TILE_TYPES.IRON_ORE || 
                                    tileType === CAVE_TILE_TYPES.COAL_ORE) {
                                    return true;
                                }
                                
                                // Проверяем построенные тайлы в пещере
                                const placedKey = `${tx},${ty}`;
                                if (world.cavePlacedTiles.has(placedKey)) {
                                    const placedType = world.cavePlacedTiles.get(placedKey);
                                    // Лестница и факел не должны быть препятствием
                                    if (placedType !== ITEM_TYPES.LADDER && placedType !== ITEM_TYPES.TORCH) {
                                        return true;
                                    }
                                }
                            }
                        }
                    }
                }
                
                return false;
            }
            
            canSmelt() {
                return this.lastSmeltTime <= 0;
            }
            
            smelt() {
                this.lastSmeltTime = this.smeltCooldown;
            }
            
            takeDamage(amount) {
                if (this.isInvulnerable) return true;
                
                this.health -= amount;
                if (this.health < 0) this.health = 0;
                
                // Активируем неуязвимость после получения урона
                this.isInvulnerable = true;
                this.invulnerabilityTimer = this.invulnerabilityDuration;
                
                return this.health > 0;
            }
            
            heal(amount) {
                this.health += amount;
                if (this.health > this.maxHealth) this.health = this.maxHealth;
            }
            
            canAttack() {
                return this.lastAttackTime <= 0;
            }
            
            canMagicAttack() {
                return this.lastMagicAttackTime <= 0;
            }
            
            attack() {
                this.lastAttackTime = this.attackCooldown;
            }
            
            magicAttack() {
                this.lastMagicAttackTime = this.magicAttackCooldown;
            }
            
            shootMagicProjectile(targetX, targetY) {
                if (!this.canMagicAttack()) return;
                
                const playerCenterX = this.x + this.size / 2;
                const playerCenterY = this.y + this.size / 2;
                // Увеличен урон с 15 до 25 и размер снаряда
                const projectile = new Projectile(
                    playerCenterX,
                    playerCenterY,
                    targetX,
                    targetY,
                    25, // Увеличенный урон снаряда
                    PROJECTILE_SPEED * 1.2,
                    '#9370DB', // Фиолетовый цвет для магического снаряда
                    20 // Увеличенный размер
                );
                
                this.projectiles.push(projectile);
                this.magicAttack();
            }
            
            respawn() {
                this.x = this.respawnX;
                this.y = this.respawnY;
                this.currentLevel = this.respawnLevel;
                this.health = this.maxHealth;
                this.isInvulnerable = true;
                this.invulnerabilityTimer = 2000; // 2 секунды неуязвимости после возрождения
            }
            
            setRespawnPoint(x, y, level) {
                this.respawnX = x;
                this.respawnY = y;
                this.respawnLevel = level;
            }
            
            draw(ctx, camera, gameTime) {
                // Цвет игрока зависит от уровня и неуязвимости
                let playerColor = this.currentLevel === WORLD_LEVELS.SURFACE ? '#2ecc71' : '#3498db';
                
                // Мерцание при неуязвимости
                if (this.isInvulnerable) {
                    const alpha = (Math.sin(Date.now() / 100) + 1) / 2;
                    playerColor = this.currentLevel === WORLD_LEVELS.SURFACE ? 
                        `rgba(46, 204, 113, ${alpha})` : 
                        `rgba(52, 152, 219, ${alpha})`;
                }
                
                // Рисуем игрока
                ctx.fillStyle = playerColor;
                ctx.fillRect(
                    this.x - camera.x, 
                    this.y - camera.y, 
                    this.size, 
                    this.size
                );
                
                // Контур игрока
                ctx.strokeStyle = this.currentLevel === WORLD_LEVELS.SURFACE ? '#27ae60' : '#2980b9';
                ctx.lineWidth = 2;
                ctx.strokeRect(
                    this.x - camera.x, 
                    this.y - camera.y, 
                    this.size, 
                    this.size
                );
                
                // Глаза игрока
                ctx.fillStyle = '#fff';
                ctx.fillRect(
                    this.x - camera.x + 6, 
                    this.y - camera.y + 6, 
                    4, 
                    4
                );
                ctx.fillRect(
                    this.x - camera.x + this.size - 10, 
                    this.y - camera.y + 6, 
                    4, 
                    4
                );
                
                // Рисуем снаряды игрока
                for (const projectile of this.projectiles) {
                    projectile.draw(ctx, camera);
                }
            }
            
            drawHealthBar(ctx) {
                const barWidth = 100;
                const barHeight = 12;
                const x = 20;
                const y = 20;
                
                // Фон полоски здоровья
                ctx.fillStyle = '#333';
                ctx.fillRect(x, y, barWidth, barHeight);
                
                // Здоровье
                const healthWidth = (this.health / this.maxHealth) * barWidth;
                ctx.fillStyle = this.health > 50 ? '#2ecc71' : this.health > 20 ? '#f39c12' : '#e74c3c';
                ctx.fillRect(x, y, healthWidth, barHeight);
                
                // Контур
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1;
                ctx.strokeRect(x, y, barWidth, barHeight);
                
                // Текст здоровья
                ctx.fillStyle = '#fff';
                ctx.font = '12px Courier New';
                ctx.textAlign = 'center';
                ctx.fillText(`Здоровье: ${Math.ceil(this.health)}`, x + barWidth/2, y + barHeight/2 + 4);
                ctx.textAlign = 'left';
            }
            
            drawLevelIndicator(ctx, gameTime) {
                const levelText = this.currentLevel === WORLD_LEVELS.SURFACE ? "Поверхность" : "Пещера";
                const levelColor = this.currentLevel === WORLD_LEVELS.SURFACE ? '#2ecc71' : '#3498db';
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(20, 40, 140, 40);
                
                ctx.fillStyle = levelColor;
                ctx.font = 'bold 14px Courier New';
                ctx.textAlign = 'left';
                ctx.fillText(`Уровень: ${levelText}`, 25, 60);
                
                // Время суток
                const timeText = gameTime.currentTime === TIME_OF_DAY.DAY ? "День" : "Ночь";
                const timeColor = gameTime.currentTime === TIME_OF_DAY.DAY ? '#FFD700' : '#4169E1';
                ctx.fillStyle = timeColor;
                ctx.fillText(`Время: ${timeText}`, 25, 80);
            }
            
            isPositionInDarkness(x, y, world, gameTime) {
                // Днем на поверхности нет темноты
                if (this.currentLevel === WORLD_LEVELS.SURFACE && gameTime.currentTime === TIME_OF_DAY.DAY) {
                    return false;
                }
                
                // Проверяем, находится ли позиция в радиусе света факела
                const tileX = Math.floor(x / TILE_SIZE);
                const tileY = Math.floor(y / TILE_SIZE);
                
                // Проверяем все факелы в мире
                const torchLightRadius = 6; // Радиус света факела в тайлах
                
                // Проверяем факелы на поверхности
                if (this.currentLevel === WORLD_LEVELS.SURFACE) {
                    for (let [key, itemType] of world.surfacePlacedTiles) {
                        if (itemType === ITEM_TYPES.TORCH) {
                            const [torchX, torchY] = key.split(',').map(Number);
                            const distance = Math.sqrt(Math.pow(torchX - tileX, 2) + Math.pow(torchY - tileY, 2));
                            if (distance <= torchLightRadius) {
                                return false;
                            }
                        }
                    }
                }
                
                // Проверяем факелы в пещере
                if (this.currentLevel === WORLD_LEVELS.CAVE) {
                    for (let [key, itemType] of world.cavePlacedTiles) {
                        if (itemType === ITEM_TYPES.TORCH) {
                            const [torchX, torchY] = key.split(',').map(Number);
                            const distance = Math.sqrt(Math.pow(torchX - tileX, 2) + Math.pow(torchY - tileY, 2));
                            if (distance <= torchLightRadius) {
                                return false;
                            }
                        }
                    }
                }
                
                // Проверяем, находится ли позиция в радиусе видимости от игрока (только в пещере или ночью на поверхности)
                const playerCenterX = this.x + this.size / 2;
                const playerCenterY = this.y + this.size / 2;
                const distance = Math.sqrt(
                    Math.pow(x - playerCenterX, 2) + 
                    Math.pow(y - playerCenterY, 2)
                );
                
                // Днем на поверхности игрок видит далеко
                if (this.currentLevel === WORLD_LEVELS.SURFACE && gameTime.currentTime === TIME_OF_DAY.DAY) {
                    return distance > TILE_SIZE * 15;
                }
                
                // Ночью на поверхности и в пещере видимость ограничена
                return distance > TILE_SIZE * 5;
            }
        }
        
        // ============================
        // КЛАСС ИНВЕНТАРЯ
        // ============================
        class Inventory {
            constructor(size) {
                this.slots = new Array(size).fill().map(() => ({
                    type: ITEM_TYPES.NONE,
                    count: 0
                }));
            }
            
            addItem(type, count = 1) {
                // Пытаемся добавить в существующий слот
                for (let slot of this.slots) {
                    if (slot.type === type && slot.count < 99) {
                        slot.count += count;
                        return true;
                    }
                }
                
                // Ищем пустой слот
                for (let slot of this.slots) {
                    if (slot.type === ITEM_TYPES.NONE) {
                        slot.type = type;
                        slot.count = count;
                        return true;
                    }
                }
                
                return false; // Инвентарь полон
            }
            
            removeItem(type, count = 1) {
                for (let i = this.slots.length - 1; i >= 0; i--) {
                    const slot = this.slots[i];
                    if (slot.type === type) {
                        if (slot.count > count) {
                            slot.count -= count;
                            return true;
                        } else if (slot.count === count) {
                            slot.type = ITEM_TYPES.NONE;
                            slot.count = 0;
                            return true;
                        }
                    }
                }
                return false; // Недостаточно предметов
            }
            
            hasItems(type, count) {
                let total = 0;
                for (let slot of this.slots) {
                    if (slot.type === type) {
                        total += slot.count;
                    }
                }
                return total >= count;
            }
            
            getItemCount(type) {
                let total = 0;
                for (let slot of this.slots) {
                    if (slot.type === type) {
                        total += slot.count;
                    }
                }
                return total;
            }
            
            getSelectedItem() {
                return this.slots[game.player.selectedSlot];
            }
            
            draw(ctx) {
                const slotSize = 42;
                const margin = 4;
                const startX = (CANVAS_WIDTH - (this.slots.length * (slotSize + margin))) / 2;
                const y = CANVAS_HEIGHT - slotSize - 20;
                
                // Фон инвентаря
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(startX - 10, y - 10, 
                            this.slots.length * (slotSize + margin) + 20, 
                            slotSize + 20);
                
                // Слоты инвентаря
                for (let i = 0; i < this.slots.length; i++) {
                    const slot = this.slots[i];
                    const x = startX + i * (slotSize + margin);
                    
                    // Фон слота
                    ctx.fillStyle = '#333';
                    ctx.fillRect(x, y, slotSize, slotSize);
                    
                    // Контур слота
                    ctx.strokeStyle = i === game.player.selectedSlot ? '#4af' : '#666';
                    ctx.lineWidth = i === game.player.selectedSlot ? 3 : 1;
                    ctx.strokeRect(x, y, slotSize, slotSize);
                    
                    // Если слот не пустой
                    if (slot.type !== ITEM_TYPES.NONE) {
                        // Предмет
                        ctx.fillStyle = ITEM_COLORS[slot.type];
                        ctx.fillRect(x + 6, y + 6, slotSize - 12, slotSize - 12);
                        
                        // Количество
                        ctx.fillStyle = '#fff';
                        ctx.font = 'bold 12px Courier New';
                        ctx.textAlign = 'right';
                        ctx.fillText(slot.count, x + slotSize - 5, y + slotSize - 5);
                        
                        // Название предмета (при наведении)
                        if (game.mouse.x >= x && game.mouse.x <= x + slotSize && 
                            game.mouse.y >= y && game.mouse.y <= y + slotSize) {
                            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                            ctx.fillRect(x, y - 25, 100, 20);
                            ctx.fillStyle = '#fff';
                            ctx.font = '12px Courier New';
                            ctx.textAlign = 'left';
                            ctx.fillText(ITEM_NAMES[slot.type], x + 5, y - 10);
                        }
                    }
                    
                    // Номер слота
                    ctx.fillStyle = '#aaa';
                    ctx.font = '10px Courier New';
                    ctx.textAlign = 'left';
                    ctx.fillText(i + 1, x + 4, y + 14);
                }
            }
        }
        
        // ============================
        // КЛАСС МИРА
        // ============================
        class World {
            constructor() {
                // Поверхность
                this.surfaceTiles = [];
                this.surfacePlacedTiles = new Map(); // Построенные тайлы: ключ -> тип
                this.originalSurfaceTiles = []; // Оригинальные тайлы для восстановления деревьев
                // Пещера
                this.caveTiles = [];
                this.cavePlacedTiles = new Map();
                
                this.generateSurface();
                this.generateCave();
                
                // Сохраняем оригинальные тайлы поверхности для восстановления деревьев
                this.saveOriginalSurface();
            }
            
            saveOriginalSurface() {
                for (let y = 0; y < WORLD_HEIGHT; y++) {
                    this.originalSurfaceTiles[y] = [];
                    for (let x = 0; x < WORLD_WIDTH; x++) {
                        this.originalSurfaceTiles[y][x] = this.surfaceTiles[y][x];
                    }
                }
            }
            
            growTrees() {
                // Восстанавливаем случайные деревья на траве
                let treesGrown = 0;
                const maxTreesToGrow = 10; // Максимальное количество деревьев за цикл роста
                
                for (let i = 0; i < 50; i++) { // Проверяем 50 случайных позиций
                    const x = Math.floor(Math.random() * WORLD_WIDTH);
                    const y = Math.floor(Math.random() * WORLD_HEIGHT);
                    
                    // Если на этой позиции была трава и сейчас трава, и не вода
                    if (this.originalSurfaceTiles[y][x] === TILE_TYPES.TREE && 
                        this.surfaceTiles[y][x] === TILE_TYPES.GRASS) {
                        
                        // Проверяем, что рядом нет других деревьев (чтобы не было скученности)
                        let hasNearbyTree = false;
                        for (let dy = -2; dy <= 2; dy++) {
                            for (let dx = -2; dx <= 2; dx++) {
                                const nx = x + dx;
                                const ny = y + dy;
                                if (nx >= 0 && nx < WORLD_WIDTH && ny >= 0 && ny < WORLD_HEIGHT) {
                                    if (this.surfaceTiles[ny][nx] === TILE_TYPES.TREE) {
                                        hasNearbyTree = true;
                                        break;
                                    }
                                }
                            }
                            if (hasNearbyTree) break;
                        }
                        
                        if (!hasNearbyTree) {
                            this.surfaceTiles[y][x] = TILE_TYPES.TREE;
                            treesGrown++;
                            
                            if (treesGrown >= maxTreesToGrow) {
                                break;
                            }
                        }
                    }
                }
                
                return treesGrown;
            }
            
            generateSurface() {
                // Инициализация пустой поверхности
                for (let y = 0; y < WORLD_HEIGHT; y++) {
                    this.surfaceTiles[y] = [];
                    for (let x = 0; x < WORLD_WIDTH; x++) {
                        this.surfaceTiles[y][x] = TILE_TYPES.GRASS;
                    }
                }
                
                // Создаем водоемы
                for (let i = 0; i < 6; i++) {
                    const waterX = Math.floor(Math.random() * (WORLD_WIDTH - 10)) + 5;
                    const waterY = Math.floor(Math.random() * (WORLD_HEIGHT - 8)) + 4;
                    const radius = Math.floor(Math.random() * 5) + 3;
                    
                    for (let y = waterY - radius; y < waterY + radius; y++) {
                        for (let x = waterX - radius; x < waterX + radius; x++) {
                            if (x >= 0 && x < WORLD_WIDTH && y >= 0 && y < WORLD_HEIGHT) {
                                const dist = Math.sqrt((x - waterX) ** 2 + (y - waterY) ** 2);
                                if (dist < radius) {
                                    this.surfaceTiles[y][x] = TILE_TYPES.WATER;
                                }
                            }
                        }
                    }
                }
                
                // Размещаем камни
                for (let i = 0; i < 30; i++) {
                    const x = Math.floor(Math.random() * WORLD_WIDTH);
                    const y = Math.floor(Math.random() * WORLD_HEIGHT);
                    if (this.surfaceTiles[y][x] === TILE_TYPES.GRASS) {
                        this.surfaceTiles[y][x] = TILE_TYPES.STONE;
                    }
                }
                
                // Размещаем деревья
                for (let i = 0; i < 25; i++) {
                    const x = Math.floor(Math.random() * WORLD_WIDTH);
                    const y = Math.floor(Math.random() * WORLD_HEIGHT);
                    if (this.surfaceTiles[y][x] === TILE_TYPES.GRASS) {
                        this.surfaceTiles[y][x] = TILE_TYPES.TREE;
                    }
                }
                
                // Гарантируем стартовую позицию без препятствий
                const startX = Math.floor(WORLD_WIDTH / 2);
                const startY = Math.floor(WORLD_HEIGHT / 2);
                for (let y = startY - 3; y <= startY + 3; y++) {
                    for (let x = startX - 3; x <= startX + 3; x++) {
                        if (x >= 0 && x < WORLD_WIDTH && y >= 0 && y < WORLD_HEIGHT) {
                            this.surfaceTiles[y][x] = TILE_TYPES.GRASS;
                        }
                    }
                }
            }
            
            generateCave() {
                // Инициализация пещеры (все стены)
                for (let y = 0; y < WORLD_HEIGHT; y++) {
                    this.caveTiles[y] = [];
                    for (let x = 0; x < WORLD_WIDTH; x++) {
                        this.caveTiles[y][x] = CAVE_TILE_TYPES.CAVE_WALL;
                    }
                }
                
                // Создаем центральную комнату (5x5 блоков)
                const centerX = Math.floor(WORLD_WIDTH / 2);
                const centerY = Math.floor(WORLD_HEIGHT / 2);
                const roomSize = 5;
                
                for (let y = centerY - roomSize; y <= centerY + roomSize; y++) {
                    for (let x = centerX - roomSize; x <= centerX + roomSize; x++) {
                        if (x >= 0 && x < WORLD_WIDTH && y >= 0 && y < WORLD_HEIGHT) {
                            this.caveTiles[y][x] = CAVE_TILE_TYPES.CAVE_FLOOR;
                        }
                    }
                }
                
                // Лестница на поверхность в центре комнаты
                this.caveTiles[centerY][centerX] = CAVE_TILE_TYPES.CAVE_EXIT;
                
                // Создаем туннели от комнаты
                this.createCaveTunnels(centerX, centerY, roomSize);
                
                // Размещаем железную руду в пещере
                for (let i = 0; i < 15; i++) {
                    let x, y;
                    do {
                        x = Math.floor(Math.random() * WORLD_WIDTH);
                        y = Math.floor(Math.random() * WORLD_HEIGHT);
                    } while (this.caveTiles[y][x] !== CAVE_TILE_TYPES.CAVE_WALL);
                    
                    this.caveTiles[y][x] = CAVE_TILE_TYPES.IRON_ORE;
                }
                
                // Размещаем уголь в пещере
                for (let i = 0; i < 20; i++) {
                    let x, y;
                    do {
                        x = Math.floor(Math.random() * WORLD_WIDTH);
                        y = Math.floor(Math.random() * WORLD_HEIGHT);
                    } while (this.caveTiles[y][x] !== CAVE_TILE_TYPES.CAVE_WALL);
                    
                    this.caveTiles[y][x] = CAVE_TILE_TYPES.COAL_ORE;
                }
                
                // Добавляем немного случайных полов в пещере для разнообразия
                for (let i = 0; i < 50; i++) {
                    const x = Math.floor(Math.random() * WORLD_WIDTH);
                    const y = Math.floor(Math.random() * WORLD_HEIGHT);
                    if (this.caveTiles[y][x] === CAVE_TILE_TYPES.CAVE_WALL) {
                        // Проверяем соседей
                        let floorNeighbors = 0;
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                const nx = x + dx;
                                const ny = y + dy;
                                if (nx >= 0 && nx < WORLD_WIDTH && ny >= 0 && ny < WORLD_HEIGHT) {
                                    if (this.caveTiles[ny][nx] === CAVE_TILE_TYPES.CAVE_FLOOR) {
                                        floorNeighbors++;
                                    }
                                }
                            }
                        }
                        if (floorNeighbors >= 3) {
                            this.caveTiles[y][x] = CAVE_TILE_TYPES.CAVE_FLOOR;
                        }
                    }
                }
            }
            
            createCaveTunnels(startX, startY, radius) {
                // Создаем 4 туннеля из центральной комнаты
                const directions = [
                    {dx: 1, dy: 0, length: 10},   // Вправо
                    {dx: -1, dy: 0, length: 10},  // Влево
                    {dx: 0, dy: 1, length: 8},    // Вниз
                    {dx: 0, dy: -1, length: 8}    // Вверх
                ];
                
                for (let dir of directions) {
                    let x = startX + (dir.dx > 0 ? radius : dir.dx < 0 ? -radius : 0);
                    let y = startY + (dir.dy > 0 ? radius : dir.dy < 0 ? -radius : 0);
                    
                    for (let i = 0; i < dir.length; i++) {
                        for (let w = -1; w <= 1; w++) {
                            const tx = x + (dir.dx === 0 ? w : 0);
                            const ty = y + (dir.dy === 0 ? w : 0);
                            
                            if (tx >= 0 && tx < WORLD_WIDTH && ty >= 0 && ty < WORLD_HEIGHT) {
                                if (this.caveTiles[ty][tx] === CAVE_TILE_TYPES.CAVE_WALL) {
                                    this.caveTiles[ty][tx] = CAVE_TILE_TYPES.CAVE_FLOOR;
                                }
                            }
                        }
                        
                        x += dir.dx;
                        y += dir.dy;
                        
                        // Останавливаемся, если вышли за границы мира
                        if (x < 0 || x >= WORLD_WIDTH || y < 0 || y >= WORLD_HEIGHT) {
                            break;
                        }
                    }
                }
            }
            
            getTileAt(x, y, level) {
                const tileX = Math.floor(x / TILE_SIZE);
                const tileY = Math.floor(y / TILE_SIZE);
                
                if (tileX >= 0 && tileX < WORLD_WIDTH && tileY >= 0 && tileY < WORLD_HEIGHT) {
                    if (level === WORLD_LEVELS.SURFACE) {
                        return this.surfaceTiles[tileY][tileX];
                    } else if (level === WORLD_LEVELS.CAVE) {
                        return this.caveTiles[tileY][tileX];
                    }
                }
                return level === WORLD_LEVELS.SURFACE ? TILE_TYPES.GRASS : CAVE_TILE_TYPES.CAVE_WALL;
            }
            
            isResourceAt(x, y, level, toolType = null) {
                const tileType = this.getTileAt(x, y, level);
                
                if (level === WORLD_LEVELS.SURFACE) {
                    // На поверхности нужна лопата для травы (создание шахты)
                    if (toolType === ITEM_TYPES.SHOVEL && tileType === TILE_TYPES.GRASS) {
                        return true;
                    }
                    // Дерево и камень можно собирать без инструмента
                    return tileType === TILE_TYPES.STONE || tileType === TILE_TYPES.TREE;
                } else if (level === WORLD_LEVELS.CAVE) {
                    // В пещере нужна кирка для добычи руды
                    if (toolType === ITEM_TYPES.PICKAXE || toolType === ITEM_TYPES.IMPROVED_PICKAXE) {
                        return tileType === CAVE_TILE_TYPES.IRON_ORE || 
                               tileType === CAVE_TILE_TYPES.COAL_ORE ||
                               tileType === CAVE_TILE_TYPES.CAVE_WALL;
                    }
                    return false;
                }
                return false;
            }
            
            collectResource(x, y, level, toolType = null) {
                const tileX = Math.floor(x / TILE_SIZE);
                const tileY = Math.floor(y / TILE_SIZE);
                
                if (tileX >= 0 && tileX < WORLD_WIDTH && tileY >= 0 && tileY < WORLD_HEIGHT) {
                    if (level === WORLD_LEVELS.SURFACE) {
                        const tileType = this.surfaceTiles[tileY][tileX];
                        
                        if (toolType === ITEM_TYPES.SHOVEL && tileType === TILE_TYPES.GRASS) {
                            // Создаем шахту вместо сбора ресурса
                            return null; // Возвращаем null, чтобы показать, что это особое действие
                        } else if (tileType === TILE_TYPES.STONE) {
                            this.surfaceTiles[tileY][tileX] = TILE_TYPES.GRASS;
                            return ITEM_TYPES.STONE;
                        } else if (tileType === TILE_TYPES.TREE) {
                            this.surfaceTiles[tileY][tileX] = TILE_TYPES.GRASS;
                            return ITEM_TYPES.WOOD;
                        }
                    } else if (level === WORLD_LEVELS.CAVE) {
                        const tileType = this.caveTiles[tileY][tileX];
                        
                        if (toolType === ITEM_TYPES.PICKAXE || toolType === ITEM_TYPES.IMPROVED_PICKAXE) {
                            if (tileType === CAVE_TILE_TYPES.IRON_ORE) {
                                this.caveTiles[tileY][tileX] = CAVE_TILE_TYPES.CAVE_FLOOR;
                                return ITEM_TYPES.IRON_ORE;
                            } else if (tileType === CAVE_TILE_TYPES.COAL_ORE) {
                                this.caveTiles[tileY][tileX] = CAVE_TILE_TYPES.CAVE_FLOOR;
                                return ITEM_TYPES.COAL;
                            } else if (tileType === CAVE_TILE_TYPES.CAVE_WALL) {
                                this.caveTiles[tileY][tileX] = CAVE_TILE_TYPES.CAVE_FLOOR;
                                return ITEM_TYPES.STONE;
                            }
                        }
                    }
                }
                return ITEM_TYPES.NONE;
            }
            
            placeTile(x, y, itemType, level) {
                const tileX = Math.floor(x / TILE_SIZE);
                const tileY = Math.floor(y / TILE_SIZE);
                const key = `${tileX},${tileY}`;
                
                if (tileX >= 0 && tileX < WORLD_WIDTH && tileY >= 0 && tileY < WORLD_HEIGHT) {
                    if (level === WORLD_LEVELS.SURFACE) {
                        // Проверяем, что место свободно (не вода и не другое здание)
                        if (this.surfaceTiles[tileY][tileX] !== TILE_TYPES.WATER && !this.surfacePlacedTiles.has(key)) {
                            this.surfacePlacedTiles.set(key, itemType);
                            return true;
                        }
                    } else if (level === WORLD_LEVELS.CAVE) {
                        // В пещере можно строить только на полу
                        if (this.caveTiles[tileY][tileX] === CAVE_TILE_TYPES.CAVE_FLOOR && !this.cavePlacedTiles.has(key)) {
                            this.cavePlacedTiles.set(key, itemType);
                            return true;
                        }
                    }
                }
                return false;
            }
            
            createMineShaft(x, y) {
                const tileX = Math.floor(x / TILE_SIZE);
                const tileY = Math.floor(y / TILE_SIZE);
                const key = `${tileX},${tileY}`;
                
                if (tileX >= 0 && tileX < WORLD_WIDTH && tileY >= 0 && tileY < WORLD_HEIGHT) {
                    if (this.surfaceTiles[tileY][tileX] === TILE_TYPES.GRASS && !this.surfacePlacedTiles.has(key)) {
                        this.surfacePlacedTiles.set(key, ITEM_TYPES.MINE_SHAFT);
                        return true;
                    }
                }
                return false;
            }
            
            isNearMineShaftOrLadder(x, y, level) {
                const tileX = Math.floor(x / TILE_SIZE);
                const tileY = Math.floor(y / TILE_SIZE);
                
                // Проверяем все соседние тайлы
                for (let dy = -1; dy <= 1; dy++) {
                    for (let dx = -1; dx <= 1; dx++) {
                        const nx = tileX + dx;
                        const ny = tileY + dy;
                        const key = `${nx},${ny}`;
                        
                        if (level === WORLD_LEVELS.SURFACE) {
                            if (this.surfacePlacedTiles.has(key) && this.surfacePlacedTiles.get(key) === ITEM_TYPES.MINE_SHAFT) {
                                return true;
                            }
                        } else if (level === WORLD_LEVELS.CAVE) {
                            if (this.cavePlacedTiles.has(key) && this.cavePlacedTiles.get(key) === ITEM_TYPES.LADDER) {
                                return true;
                            }
                            // Также проверяем лестницу на поверхность (фиксированную)
                            if (this.caveTiles[ny] && this.caveTiles[ny][nx] === CAVE_TILE_TYPES.CAVE_EXIT) {
                                return true;
                            }
                        }
                    }
                }
                return false;
            }
            
            isNearFurnace(x, y, level) {
                const tileX = Math.floor(x / TILE_SIZE);
                const tileY = Math.floor(y / TILE_SIZE);
                
                // Проверяем все соседние тайлы
                for (let dy = -1; dy <= 1; dy++) {
                    for (let dx = -1; dx <= 1; dx++) {
                        const nx = tileX + dx;
                        const ny = tileY + dy;
                        const key = `${nx},${ny}`;
                        
                        if (level === WORLD_LEVELS.SURFACE) {
                            if (this.surfacePlacedTiles.has(key) && this.surfacePlacedTiles.get(key) === ITEM_TYPES.FURNACE) {
                                return true;
                            }
                        } else if (level === WORLD_LEVELS.CAVE) {
                            if (this.cavePlacedTiles.has(key) && this.cavePlacedTiles.get(key) === ITEM_TYPES.FURNACE) {
                                return true;
                            }
                        }
                    }
                }
                return false;
            }
            
            isPositionNearTorch(x, y, level) {
                const tileX = Math.floor(x / TILE_SIZE);
                const tileY = Math.floor(y / TILE_SIZE);
                const torchRadius = 8; // Радиус, в котором мобы не спавнятся
                
                if (level === WORLD_LEVELS.SURFACE) {
                    for (let [key, itemType] of this.surfacePlacedTiles) {
                        if (itemType === ITEM_TYPES.TORCH) {
                            const [torchX, torchY] = key.split(',').map(Number);
                            const distance = Math.sqrt(Math.pow(torchX - tileX, 2) + Math.pow(torchY - tileY, 2));
                            if (distance <= torchRadius) {
                                return true;
                            }
                        }
                    }
                } else if (level === WORLD_LEVELS.CAVE) {
                    for (let [key, itemType] of this.cavePlacedTiles) {
                        if (itemType === ITEM_TYPES.TORCH) {
                            const [torchX, torchY] = key.split(',').map(Number);
                            const distance = Math.sqrt(Math.pow(torchX - tileX, 2) + Math.pow(torchY - tileY, 2));
                            if (distance <= torchRadius) {
                                return true;
                            }
                        }
                    }
                }
                
                return false;
            }
            
            // Метод для разрушения алтаря улучшенной киркой
            breakAltar(x, y, level) {
                const tileX = Math.floor(x / TILE_SIZE);
                const tileY = Math.floor(y / TILE_SIZE);
                const key = `${tileX},${tileY}`;
                
                if (level === WORLD_LEVELS.SURFACE) {
                    if (this.surfacePlacedTiles.has(key)) {
                        const itemType = this.surfacePlacedTiles.get(key);
                        if (itemType === ITEM_TYPES.ALTAR || itemType === ITEM_TYPES.RESURRECTION_ALTAR) {
                            this.surfacePlacedTiles.delete(key);
                            return itemType;
                        }
                    }
                } else if (level === WORLD_LEVELS.CAVE) {
                    if (this.cavePlacedTiles.has(key)) {
                        const itemType = this.cavePlacedTiles.get(key);
                        if (itemType === ITEM_TYPES.ALTAR || itemType === ITEM_TYPES.RESURRECTION_ALTAR) {
                            this.cavePlacedTiles.delete(key);
                            return itemType;
                        }
                    }
                }
                return ITEM_TYPES.NONE;
            }
            
            // Метод для копания 3 тайлов улучшенной киркой
            digArea(x, y, level) {
                const tileX = Math.floor(x / TILE_SIZE);
                const tileY = Math.floor(y / TILE_SIZE);
                const minedItems = [];
                
                // Копаем область 3x3
                for (let dy = -1; dy <= 1; dy++) {
                    for (let dx = -1; dx <= 1; dx++) {
                        const nx = tileX + dx;
                        const ny = tileY + dy;
                        
                        if (nx >= 0 && nx < WORLD_WIDTH && ny >= 0 && ny < WORLD_HEIGHT) {
                            if (level === WORLD_LEVELS.CAVE) {
                                const tileType = this.caveTiles[ny][nx];
                                if (tileType === CAVE_TILE_TYPES.IRON_ORE) {
                                    this.caveTiles[ny][nx] = CAVE_TILE_TYPES.CAVE_FLOOR;
                                    minedItems.push(ITEM_TYPES.IRON_ORE);
                                } else if (tileType === CAVE_TILE_TYPES.COAL_ORE) {
                                    this.caveTiles[ny][nx] = CAVE_TILE_TYPES.CAVE_FLOOR;
                                    minedItems.push(ITEM_TYPES.COAL);
                                } else if (tileType === CAVE_TILE_TYPES.CAVE_WALL) {
                                    this.caveTiles[ny][nx] = CAVE_TILE_TYPES.CAVE_FLOOR;
                                    minedItems.push(ITEM_TYPES.STONE);
                                }
                            }
                        }
                    }
                }
                
                return minedItems;
            }
            
            draw(ctx, camera, level, gameTime) {
                // Определяем видимую область
                const startX = Math.max(0, Math.floor(camera.x / TILE_SIZE));
                const endX = Math.min(WORLD_WIDTH, Math.ceil((camera.x + CANVAS_WIDTH) / TILE_SIZE));
                const startY = Math.max(0, Math.floor(camera.y / TILE_SIZE));
                const endY = Math.min(WORLD_HEIGHT, Math.ceil((camera.y + CANVAS_HEIGHT) / TILE_SIZE));
                
                if (level === WORLD_LEVELS.SURFACE) {
                    // Затемнение для ночи
                    if (gameTime.currentTime === TIME_OF_DAY.NIGHT) {
                        ctx.fillStyle = 'rgba(0, 0, 10, 0.7)';
                        ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                    }
                    
                    // Рисуем тайлы поверхности
                    for (let y = startY; y < endY; y++) {
                        for (let x = startX; x < endX; x++) {
                            const tileType = this.surfaceTiles[y][x];
                            const drawX = x * TILE_SIZE - camera.x;
                            const drawY = y * TILE_SIZE - camera.y;
                            
                            // Рисуем фон тайла
                            switch (tileType) {
                                case TILE_TYPES.GRASS:
                                    // Трава меняет цвет в зависимости от времени суток
                                    if (gameTime.currentTime === TIME_OF_DAY.DAY) {
                                        ctx.fillStyle = '#2d5a27';
                                    } else {
                                        ctx.fillStyle = '#1a3a1a';
                                    }
                                    break;
                                case TILE_TYPES.WATER:
                                    // Вода темнее ночью
                                    if (gameTime.currentTime === TIME_OF_DAY.DAY) {
                                        ctx.fillStyle = '#1a3a6e';
                                    } else {
                                        ctx.fillStyle = '#0a1a3e';
                                    }
                                    break;
                                case TILE_TYPES.STONE:
                                    ctx.fillStyle = '#555';
                                    break;
                                case TILE_TYPES.TREE:
                                    // Деревья темнее ночью
                                    if (gameTime.currentTime === TIME_OF_DAY.DAY) {
                                        ctx.fillStyle = '#2d5a27';
                                    } else {
                                        ctx.fillStyle = '#1a3a1a';
                                    }
                                    break;
                            }
                            
                            // Если позиция в темноте, делаем ее еще темнее
                            const worldX = x * TILE_SIZE + TILE_SIZE/2;
                            const worldY = y * TILE_SIZE + TILE_SIZE/2;
                            if (game.player.isPositionInDarkness(worldX, worldY, this, gameTime)) {
                                // Затемняем тайл
                                ctx.fillStyle = this.darkenColor(ctx.fillStyle, 0.6);
                            }
                            
                            ctx.fillRect(drawX, drawY, TILE_SIZE, TILE_SIZE);
                            
                            // Детали тайлов
                            switch (tileType) {
                                case TILE_TYPES.GRASS:
                                    // Трава
                                    if (gameTime.currentTime === TIME_OF_DAY.DAY) {
                                        ctx.fillStyle = '#3a6a32';
                                    } else {
                                        ctx.fillStyle = '#2a4a22';
                                    }
                                    
                                    // Если позиция в темноте, не рисуем детали
                                    if (!game.player.isPositionInDarkness(worldX, worldY, this, gameTime)) {
                                        for (let i = 0; i < 5; i++) {
                                            const px = drawX + Math.random() * TILE_SIZE;
                                            const py = drawY + Math.random() * TILE_SIZE;
                                            ctx.fillRect(px, py, 2, 2);
                                        }
                                    }
                                    break;
                                    
                                case TILE_TYPES.WATER:
                                    // Волны на воду
                                    if (gameTime.currentTime === TIME_OF_DAY.DAY) {
                                        ctx.fillStyle = '#2a4a8e';
                                    } else {
                                        ctx.fillStyle = '#1a2a6e';
                                    }
                                    
                                    // Если позиция в темноте, не рисуем детали
                                    if (!game.player.isPositionInDarkness(worldX, worldY, this, gameTime)) {
                                        for (let i = 0; i < 3; i++) {
                                            const px = drawX + Math.random() * TILE_SIZE;
                                            const py = drawY + Math.random() * TILE_SIZE;
                                            ctx.fillRect(px, py, 4, 1);
                                        }
                                    }
                                    break;
                                    
                                case TILE_TYPES.STONE:
                                    // Камень
                                    // Если позиция в темноте, не рисуем детали
                                    if (!game.player.isPositionInDarkness(worldX, worldY, this, gameTime)) {
                                        ctx.fillStyle = '#777';
                                        ctx.fillRect(drawX + 4, drawY + 4, TILE_SIZE - 8, TILE_SIZE - 8);
                                        ctx.fillStyle = '#444';
                                        ctx.strokeRect(drawX + 4, drawY + 4, TILE_SIZE - 8, TILE_SIZE - 8);
                                    }
                                    break;
                                    
                                case TILE_TYPES.TREE:
                                    // Дерево (ствол)
                                    if (!game.player.isPositionInDarkness(worldX, worldY, this, gameTime)) {
                                        if (gameTime.currentTime === TIME_OF_DAY.DAY) {
                                            ctx.fillStyle = '#8B4513';
                                        } else {
                                            ctx.fillStyle = '#5a2d0b';
                                        }
                                        ctx.fillRect(drawX + 12, drawY + 16, 8, 16);
                                        // Крона
                                        if (gameTime.currentTime === TIME_OF_DAY.DAY) {
                                            ctx.fillStyle = '#2e7d32';
                                        } else {
                                            ctx.fillStyle = '#1e5d22';
                                        }
                                        ctx.beginPath();
                                        ctx.arc(drawX + 16, drawY + 12, 10, 0, Math.PI * 2);
                                        ctx.fill();
                                    }
                                    break;
                            }
                        }
                    }
                    
                    // Рисуем построенные игроком тайлы на поверхности
                    for (let [key, itemType] of this.surfacePlacedTiles) {
                        const [x, y] = key.split(',').map(Number);
                        const drawX = x * TILE_SIZE - camera.x;
                        const drawY = y * TILE_SIZE - camera.y;
                        const worldX = x * TILE_SIZE + TILE_SIZE/2;
                        const worldY = y * TILE_SIZE + TILE_SIZE/2;
                        
                        // Если позиция в темноте, пропускаем отрисовку
                        if (!game.player.isPositionInDarkness(worldX, worldY, this, gameTime)) {
                            this.drawPlacedTile(ctx, drawX, drawY, itemType, gameTime);
                        }
                    }
                    
                    // Рисуем свет факелов
                    this.drawTorchLight(ctx, camera, level, gameTime);
                } else if (level === WORLD_LEVELS.CAVE) {
                    // Темный фон для пещеры
                    ctx.fillStyle = '#000';
                    ctx.fillRect(startX * TILE_SIZE - camera.x, startY * TILE_SIZE - camera.y, 
                                (endX - startX) * TILE_SIZE, (endY - startY) * TILE_SIZE);
                    
                    // Рисуем тайлы пещеры
                    for (let y = startY; y < endY; y++) {
                        for (let x = startX; x < endX; x++) {
                            const tileType = this.caveTiles[y][x];
                            const drawX = x * TILE_SIZE - camera.x;
                            const drawY = y * TILE_SIZE - camera.y;
                            const worldX = x * TILE_SIZE;
                            const worldY = y * TILE_SIZE;
                            
                            // Рисуем только если тайл в радиусе видимости от игрока или факела
                            if (!game.player.isPositionInDarkness(worldX + TILE_SIZE/2, worldY + TILE_SIZE/2, this, gameTime)) {
                                // Рисуем тайлы пещеры
                                switch (tileType) {
                                    case CAVE_TILE_TYPES.CAVE_WALL:
                                        ctx.fillStyle = '#333';
                                        ctx.fillRect(drawX, drawY, TILE_SIZE, TILE_SIZE);
                                        
                                        // Текстура стены
                                        ctx.fillStyle = '#222';
                                        for (let i = 0; i < 4; i++) {
                                            ctx.fillRect(drawX + 2 + i * 7, drawY + 2, 3, TILE_SIZE - 4);
                                        }
                                        break;
                                        
                                    case CAVE_TILE_TYPES.CAVE_FLOOR:
                                        ctx.fillStyle = '#222';
                                        ctx.fillRect(drawX, drawY, TILE_SIZE, TILE_SIZE);
                                        
                                        // Текстура пола
                                        ctx.fillStyle = '#2a2a2a';
                                        for (let i = 0; i < 3; i++) {
                                            for (let j = 0; j < 3; j++) {
                                                ctx.fillRect(drawX + 4 + i * 8, drawY + 4 + j * 8, 2, 2);
                                            }
                                        }
                                        break;
                                        
                                    case CAVE_TILE_TYPES.IRON_ORE:
                                        ctx.fillStyle = '#222';
                                        ctx.fillRect(drawX, drawY, TILE_SIZE, TILE_SIZE);
                                        
                                        // Железная руда
                                        ctx.fillStyle = '#B22222';
                                        ctx.fillRect(drawX + 4, drawY + 4, TILE_SIZE - 8, TILE_SIZE - 8);
                                        
                                        // Блеск руды
                                        ctx.fillStyle = '#FF6347';
                                        ctx.fillRect(drawX + 8, drawY + 8, 4, 4);
                                        ctx.fillRect(drawX + 20, drawY + 20, 3, 3);
                                        break;
                                        
                                    case CAVE_TILE_TYPES.COAL_ORE:
                                        ctx.fillStyle = '#222';
                                        ctx.fillRect(drawX, drawY, TILE_SIZE, TILE_SIZE);
                                        
                                        // Уголь
                                        ctx.fillStyle = '#2F4F4F';
                                        ctx.fillRect(drawX + 4, drawY + 4, TILE_SIZE - 8, TILE_SIZE - 8);
                                        
                                        // Детали угля
                                        ctx.fillStyle = '#000';
                                        for (let i = 0; i < 5; i++) {
                                            ctx.fillRect(drawX + 6 + i * 5, drawY + 12, 3, 8);
                                        }
                                        break;
                                        
                                    case CAVE_TILE_TYPES.CAVE_EXIT:
                                        ctx.fillStyle = '#222';
                                        ctx.fillRect(drawX, drawY, TILE_SIZE, TILE_SIZE);
                                        
                                        // Лестница на поверхность
                                        ctx.fillStyle = '#D2B48C';
                                        for (let i = 0; i < 3; i++) {
                                            ctx.fillRect(drawX + 4, drawY + 8 + i * 8, TILE_SIZE - 8, 3);
                                        }
                                        ctx.fillRect(drawX + 8, drawY + 4, 3, TILE_SIZE - 8);
                                        ctx.fillRect(drawX + 20, drawY + 4, 3, TILE_SIZE - 8);
                                        break;
                                }
                            }
                        }
                    }
                    
                    // Рисуем построенные игроком тайлы в пещере (только если в радиусе видимости)
                    for (let [key, itemType] of this.cavePlacedTiles) {
                        const [x, y] = key.split(',').map(Number);
                        const drawX = x * TILE_SIZE - camera.x;
                        const drawY = y * TILE_SIZE - camera.y;
                        const worldX = x * TILE_SIZE + TILE_SIZE/2;
                        const worldY = y * TILE_SIZE + TILE_SIZE/2;
                        
                        if (!game.player.isPositionInDarkness(worldX, worldY, this, gameTime)) {
                            this.drawPlacedTile(ctx, drawX, drawY, itemType, gameTime);
                        }
                    }
                    
                    // Рисуем свет факелов
                    this.drawTorchLight(ctx, camera, level, gameTime);
                }
            }
            
            darkenColor(color, factor) {
                // Извлекаем компоненты цвета
                const match = color.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([\d.]+))?\)/);
                if (match) {
                    let r = parseInt(match[1]);
                    let g = parseInt(match[2]);
                    let b = parseInt(match[3]);
                    let a = match[4] ? parseFloat(match[4]) : 1;
                    
                    // Затемняем цвет
                    r = Math.floor(r * factor);
                    g = Math.floor(g * factor);
                    b = Math.floor(b * factor);
                    
                    return `rgba(${r}, ${g}, ${b}, ${a})`;
                }
                
                return color;
            }
            
            drawPlacedTile(ctx, x, y, itemType, gameTime) {
                switch (itemType) {
                    case ITEM_TYPES.WALL:
                        // Стена
                        ctx.fillStyle = '#696969';
                        ctx.fillRect(x + 2, y + 2, TILE_SIZE - 4, TILE_SIZE - 4);
                        ctx.fillStyle = '#555';
                        ctx.fillRect(x + 4, y + 4, TILE_SIZE - 8, TILE_SIZE - 8);
                        
                        // Текстура стены
                        ctx.fillStyle = '#444';
                        for (let i = 0; i < 4; i++) {
                            ctx.fillRect(x + 6 + i * 6, y + 8, 2, TILE_SIZE - 12);
                        }
                        break;
                        
                    case ITEM_TYPES.ALTAR:
                        // Алтарь
                        ctx.fillStyle = '#800080';
                        ctx.fillRect(x + 2, y + 2, TILE_SIZE - 4, TILE_SIZE - 4);
                        ctx.fillStyle = '#4B0082';
                        ctx.fillRect(x + 4, y + 4, TILE_SIZE - 8, TILE_SIZE - 8);
                        
                        // Символ на алтаре
                        ctx.fillStyle = '#FFD700';
                        ctx.beginPath();
                        ctx.arc(x + TILE_SIZE/2, y + TILE_SIZE/2, 8, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.fillStyle = '#800080';
                        ctx.beginPath();
                        ctx.arc(x + TILE_SIZE/2, y + TILE_SIZE/2, 4, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                        
                    case ITEM_TYPES.MINE_SHAFT:
                        // Шахта
                        ctx.fillStyle = '#654321';
                        ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
                        
                        // Вход в шахту
                        ctx.fillStyle = '#222';
                        ctx.fillRect(x + 8, y + 8, TILE_SIZE - 16, TILE_SIZE - 16);
                        
                        // Лестница в шахте
                        ctx.fillStyle = '#D2B48C';
                        for (let i = 0; i < 3; i++) {
                            ctx.fillRect(x + 6, y + 6 + i * 8, TILE_SIZE - 12, 3);
                        }
                        break;
                        
                    case ITEM_TYPES.FURNACE:
                        // Печка
                        ctx.fillStyle = '#8B0000';
                        ctx.fillRect(x + 2, y + 2, TILE_SIZE - 4, TILE_SIZE - 4);
                        ctx.fillStyle = '#A52A2A';
                        ctx.fillRect(x + 4, y + 4, TILE_SIZE - 8, TILE_SIZE - 8);
                        
                        // Отверстие печки
                        ctx.fillStyle = '#222';
                        ctx.fillRect(x + 10, y + 10, TILE_SIZE - 20, TILE_SIZE - 20);
                        
                        // Огонь (если есть уголь)
                        if (Math.random() > 0.7) {
                            ctx.fillStyle = '#FF4500';
                            ctx.fillRect(x + 12, y + 20, TILE_SIZE - 24, 4);
                        }
                        break;
                        
                    case ITEM_TYPES.LADDER:
                        // Лестница
                        ctx.fillStyle = '#222';
                        ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
                        
                        ctx.fillStyle = '#D2B48C';
                        for (let i = 0; i < 4; i++) {
                            ctx.fillRect(x + 8, y + 4 + i * 7, TILE_SIZE - 16, 3);
                        }
                        ctx.fillRect(x + 6, y + 4, 3, TILE_SIZE - 8);
                        ctx.fillRect(x + 22, y + 4, 3, TILE_SIZE - 8);
                        break;
                        
                    case ITEM_TYPES.TORCH:
                        // Факел
                        ctx.fillStyle = '#8B4513';
                        ctx.fillRect(x + 14, y + 20, 4, 12);
                        
                        // Пламя факла
                        const flameSize = 6 + Math.sin(Date.now() / 200) * 2;
                        ctx.fillStyle = '#FF4500';
                        ctx.beginPath();
                        ctx.arc(x + TILE_SIZE/2, y + 18, flameSize, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.fillStyle = '#FFD700';
                        ctx.beginPath();
                        ctx.arc(x + TILE_SIZE/2, y + 18, flameSize * 0.6, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Свет факла (рисуется отдельно в drawTorchLight)
                        break;
                        
                    case ITEM_TYPES.RESURRECTION_ALTAR:
                        // Алтарь возрождения
                        ctx.fillStyle = '#00FF00';
                        ctx.fillRect(x + 2, y + 2, TILE_SIZE - 4, TILE_SIZE - 4);
                        ctx.fillStyle = '#008800';
                        ctx.fillRect(x + 4, y + 4, TILE_SIZE - 8, TILE_SIZE - 8);
                        
                        // Символ возрождения
                        ctx.fillStyle = '#FFFFFF';
                        ctx.beginPath();
                        ctx.arc(x + TILE_SIZE/2, y + TILE_SIZE/2, 8, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.fillStyle = '#00FF00';
                        ctx.beginPath();
                        ctx.arc(x + TILE_SIZE/2, y + TILE_SIZE/2, 4, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Крест (символ возрождения)
                        ctx.fillStyle = '#008800';
                        ctx.fillRect(x + TILE_SIZE/2 - 1, y + 10, 2, 12);
                        ctx.fillRect(x + 10, y + TILE_SIZE/2 - 1, 12, 2);
                        break;
                }
            }
            
            drawTorchLight(ctx, camera, level, gameTime) {
                // Собираем все факелы на текущем уровне
                let torches = [];
                
                if (level === WORLD_LEVELS.SURFACE) {
                    for (let [key, itemType] of this.surfacePlacedTiles) {
                        if (itemType === ITEM_TYPES.TORCH) {
                            const [x, y] = key.split(',').map(Number);
                            torches.push({x: x * TILE_SIZE + TILE_SIZE/2, y: y * TILE_SIZE + TILE_SIZE/2});
                        }
                    }
                } else if (level === WORLD_LEVELS.CAVE) {
                    for (let [key, itemType] of this.cavePlacedTiles) {
                        if (itemType === ITEM_TYPES.TORCH) {
                            const [x, y] = key.split(',').map(Number);
                            torches.push({x: x * TILE_SIZE + TILE_SIZE/2, y: y * TILE_SIZE + TILE_SIZE/2});
                        }
                    }
                }
                
                // Рисуем свет для каждого факела
                for (let torch of torches) {
                    const centerX = torch.x - camera.x;
                    const centerY = torch.y - camera.y;
                    const radius = TILE_SIZE * 6; // Радиус света факела
                    
                    const gradient = ctx.createRadialGradient(
                        centerX, centerY, radius * 0.1,
                        centerX, centerY, radius
                    );
                    
                    if (level === WORLD_LEVELS.SURFACE && gameTime.currentTime === TIME_OF_DAY.DAY) {
                        // Днем свет факела менее заметен
                        gradient.addColorStop(0, 'rgba(255, 215, 0, 0.3)');
                        gradient.addColorStop(0.7, 'rgba(255, 165, 0, 0.1)');
                        gradient.addColorStop(1, 'rgba(255, 140, 0, 0)');
                    } else {
                        // Ночью и в пещере свет ярче
                        gradient.addColorStop(0, 'rgba(255, 215, 0, 0.5)');
                        gradient.addColorStop(0.7, 'rgba(255, 165, 0, 0.2)');
                        gradient.addColorStop(1, 'rgba(255, 140, 0, 0)');
                    }
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }
        
        // ============================
        // КЛАСС ПРОДЖЕКТАЙЛА
        // ============================
        class Projectile {
            constructor(x, y, targetX, targetY, damage, speed = PROJECTILE_SPEED, color = '#ff4444', size = PROJECTILE_SIZE) {
                this.x = x;
                this.y = y;
                this.size = size; // Используем переданный размер
                this.damage = damage;
                this.speed = speed;
                this.color = color;
                
                // Вычисляем направление к цели
                const dx = targetX - x;
                const dy = targetY - y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                this.velocityX = (dx / distance) * speed;
                this.velocityY = (dy / distance) * speed;
                
                this.active = true;
            }
            
            update(deltaTime) {
                if (!this.active) return;
                
                this.x += this.velocityX;
                this.y += this.velocityY;
                
                // Проверяем выход за границы мира
                if (this.x < 0 || this.x > WORLD_WIDTH * TILE_SIZE || 
                    this.y < 0 || this.y > WORLD_HEIGHT * TILE_SIZE) {
                    this.active = false;
                }
            }
            
            checkCollision(target) {
                if (!this.active) return false;
                
                const targetCenterX = target.x + (target.size ? target.size/2 : 0);
                const targetCenterY = target.y + (target.size ? target.size/2 : 0);
                
                const dx = this.x - targetCenterX;
                const dy = this.y - targetCenterY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                const targetRadius = target.size ? target.size/2 : 16;
                return distance < (this.size/2 + targetRadius);
            }
            
            draw(ctx, camera) {
                if (!this.active) return;
                
                // Основной цвет снаряда
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(
                    this.x - camera.x,
                    this.y - camera.y,
                    this.size / 2,
                    0,
                    Math.PI * 2
                );
                ctx.fill();
                
                // Яркое ядро
                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.arc(
                    this.x - camera.x,
                    this.y - camera.y,
                    this.size / 4,
                    0,
                    Math.PI * 2
                );
                ctx.fill();
                
                // Свечение
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(
                    this.x - camera.x,
                    this.y - camera.y,
                    this.size / 2 + 2,
                    0,
                    Math.PI * 2
                );
                ctx.stroke();
            }
        }
        
        // ============================
        // КЛАСС БОССА ПОВЕРХНОСТИ
        // ============================
        class Boss {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.size = BOSS_SIZE;
                this.health = 150;
                this.maxHealth = 150;
                this.speed = 1.5;
                this.damage = 15;
                this.lastAttackTime = 0;
                this.attackCooldown = 1000; // мс
                this.alive = true;
                this.isCaveBoss = false;
            }
            
            update(player, deltaTime) {
                if (!this.alive) return;
                
                // Движение к игроку
                const dx = player.x - this.x;
                const dy = player.y - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 0) {
                    this.x += (dx / distance) * this.speed;
                    this.y += (dy / distance) * this.speed;
                }
                
                // Обновление времени перезарядки атаки
                if (this.lastAttackTime > 0) {
                    this.lastAttackTime -= deltaTime;
                }
                
                // Проверка столкновения с игроком
                if (this.checkCollision(player) && this.lastAttackTime <= 0) {
                    player.takeDamage(this.damage);
                    this.lastAttackTime = this.attackCooldown;
                }
            }
            
            checkCollision(player) {
                const dx = this.x - player.x;
                const dy = this.y - player.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                return distance < (this.size / 2 + player.size / 2);
            }
            
            takeDamage(amount) {
                this.health -= amount;
                if (this.health <= 0) {
                    this.health = 0;
                    this.alive = false;
                    
                    // Дроп улучшенной кирки с первого босса
                    if (!this.isCaveBoss && Math.random() < 1.0) { // 100% шанс
                        // Добавляем улучшенную кирку в инвентарь игрока
                        if (game.player.inventory.addItem(ITEM_TYPES.IMPROVED_PICKAXE, 1)) {
                            game.showStatus('Получена: Улучшенная кирка! ЛКМ: ломает алтари и копает 3 тайла.');
                        }
                    }
                }
            }
            
            draw(ctx, camera) {
                if (!this.alive) return;
                
                // Тело босса (большой красный круг)
                ctx.fillStyle = '#c0392b';
                ctx.beginPath();
                ctx.arc(
                    this.x - camera.x,
                    this.y - camera.y,
                    this.size / 2,
                    0,
                    Math.PI * 2
                );
                ctx.fill();
                
                // Глаза босса (желтые круги)
                ctx.fillStyle = '#f1c40f';
                ctx.beginPath();
                ctx.arc(
                    this.x - camera.x - 15,
                    this.y - camera.y - 10,
                    8,
                    0,
                    Math.PI * 2
                );
                ctx.fill();
                
                ctx.beginPath();
                ctx.arc(
                    this.x - camera.x + 15,
                    this.y - camera.y - 10,
                    8,
                    0,
                    Math.PI * 2
                );
                ctx.fill();
                
                // Зрачки
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(
                    this.x - camera.x - 15,
                    this.y - camera.y - 10,
                    3,
                    0,
                    Math.PI * 2
                );
                ctx.fill();
                
                ctx.beginPath();
                ctx.arc(
                    this.x - camera.x + 15,
                    this.y - camera.y - 10,
                    3,
                    0,
                    Math.PI * 2
                );
                ctx.fill();
                
                // Рот
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(
                    this.x - camera.x,
                    this.y - camera.y + 10,
                    15,
                    0,
                    Math.PI
                );
                ctx.stroke();
            }
        }
        
        // ============================
        // КЛАСС ПЕЩЕРНОГО БОССА
        // ============================
        class CaveBoss extends Boss {
            constructor(x, y) {
                super(x, y);
                this.size = CAVE_BOSS_SIZE;
                this.health = 250;
                this.maxHealth = 250;
                this.speed = 1.2;
                this.damage = 20;
                this.projectiles = [];
                this.lastProjectileTime = 0;
                this.projectileCooldown = 2000; // мс
                this.projectileDamage = 15; // Увеличен урон с 10 до 15
                this.isCaveBoss = true;
            }
            
            update(player, deltaTime) {
                if (!this.alive) return;
                
                // Движение к игроку (медленнее, чем обычный босс)
                const dx = player.x - this.x;
                const dy = player.y - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // Двигаемся только если игрок достаточно далеко
                if (distance > 100) {
                    this.x += (dx / distance) * this.speed;
                    this.y += (dy / distance) * this.speed;
                }
                
                // Обновление времени перезарядки атаки
                if (this.lastAttackTime > 0) {
                    this.lastAttackTime -= deltaTime;
                }
                
                // Обновление времени перезарядки снарядов
                if (this.lastProjectileTime > 0) {
                    this.lastProjectileTime -= deltaTime;
                }
                
                // Проверка столкновения с игроком
                if (this.checkCollision(player) && this.lastAttackTime <= 0) {
                    player.takeDamage(this.damage);
                    this.lastAttackTime = this.attackCooldown;
                }
                
                // Стрельба снарядами
                if (this.lastProjectileTime <= 0 && distance < 400) {
                    this.shootProjectile(player);
                    this.lastProjectileTime = this.projectileCooldown;
                }
                
                // Обновление снарядов
                for (let i = this.projectiles.length - 1; i >= 0; i--) {
                    const projectile = this.projectiles[i];
                    projectile.update(deltaTime);
                    
                    // Проверка столкновения с игроком
                    if (projectile.checkCollision(player)) {
                        player.takeDamage(projectile.damage);
                        projectile.active = false;
                    }
                    
                    // Удаление неактивных снарядов
                    if (!projectile.active) {
                        this.projectiles.splice(i, 1);
                    }
                }
            }
            
            shootProjectile(player) {
                // Создаем снаряд, направленный в игрока
                const projectile = new Projectile(
                    this.x,
                    this.y,
                    player.x + player.size/2,
                    player.y + player.size/2,
                    this.projectileDamage,
                    PROJECTILE_SPEED * 0.8,
                    '#8a2be2' // Фиолетовый цвет для пещерного босса
                );
                
                this.projectiles.push(projectile);
                
                // Иногда создаем несколько снарядов
                if (Math.random() < 0.3) {
                    // Создаем еще 2 снаряда под небольшим углом
                    const angle1 = Math.atan2(
                        player.y + player.size/2 - this.y,
                        player.x + player.size/2 - this.x
                    ) + 0.3;
                    
                    const angle2 = Math.atan2(
                        player.y + player.size/2 - this.y,
                        player.x + player.size/2 - this.x
                    ) - 0.3;
                    
                    const projectile1 = new Projectile(
                        this.x,
                        this.y,
                        this.x + Math.cos(angle1) * 100,
                        this.y + Math.sin(angle1) * 100,
                        this.projectileDamage,
                        PROJECTILE_SPEED * 0.8,
                        '#8a2be2'
                    );
                    
                    const projectile2 = new Projectile(
                        this.x,
                        this.y,
                        this.x + Math.cos(angle2) * 100,
                        this.y + Math.sin(angle2) * 100,
                        this.projectileDamage,
                        PROJECTILE_SPEED * 0.8,
                        '#8a2be2'
                    );
                    
                    this.projectiles.push(projectile1, projectile2);
                }
            }
            
            draw(ctx, camera) {
                if (!this.alive) return;
                
                // Тело пещерного босса (большой фиолетовый круг с текстурами)
                ctx.fillStyle = '#8a2be2';
                ctx.beginPath();
                ctx.arc(
                    this.x - camera.x,
                    this.y - camera.y,
                    this.size / 2,
                    0,
                    Math.PI * 2
                );
                ctx.fill();
                
                // Текстура на теле
                ctx.fillStyle = '#6a1bb9';
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    const spikeLength = this.size / 3;
                    ctx.beginPath();
                    ctx.moveTo(
                        this.x - camera.x + Math.cos(angle) * (this.size / 2 - 5),
                        this.y - camera.y + Math.sin(angle) * (this.size / 2 - 5)
                    );
                    ctx.lineTo(
                        this.x - camera.x + Math.cos(angle) * (this.size / 2 + spikeLength),
                        this.y - camera.y + Math.sin(angle) * (this.size / 2 + spikeLength)
                    );
                    ctx.lineTo(
                        this.x - camera.x + Math.cos(angle + 0.3) * (this.size / 2),
                        this.y - camera.y + Math.sin(angle + 0.3) * (this.size / 2)
                    );
                    ctx.closePath();
                    ctx.fill();
                }
                
                // Глазы пещерного босса (светящиеся)
                ctx.fillStyle = '#00ffff';
                ctx.beginPath();
                ctx.arc(
                    this.x - camera.x - 18,
                    this.y - camera.y - 12,
                    10,
                    0,
                    Math.PI * 2
                );
                ctx.fill();
                
                ctx.beginPath();
                ctx.arc(
                    this.x - camera.x + 18,
                    this.y - camera.y - 12,
                    10,
                    0,
                    Math.PI * 2
                );
                ctx.fill();
                
                // Зрачки
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(
                    this.x - camera.x - 18,
                    this.y - camera.y - 12,
                    4,
                    0,
                    Math.PI * 2
                );
                ctx.fill();
                
                ctx.beginPath();
                ctx.arc(
                    this.x - camera.x + 18,
                    this.y - camera.y - 12,
                    4,
                    0,
                    Math.PI * 2
                );
                ctx.fill();
                
                // Рот (больше и страшнее)
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(
                    this.x - camera.x,
                    this.y - camera.y + 15,
                    20,
                    0,
                    Math.PI,
                    false
                );
                ctx.fill();
                
                // Зубы
                ctx.fillStyle = '#fff';
                for (let i = 0; i < 6; i++) {
                    const toothX = this.x - camera.x - 15 + i * 6;
                    ctx.fillRect(toothX, this.y - camera.y + 15, 3, 8);
                }
                
                // Рисуем снаряды
                for (const projectile of this.projectiles) {
                    projectile.draw(ctx, camera);
                }
            }
        }
        
        // ============================
        // КЛАСС МОБА (БАЗОВЫЙ)
        // ============================
        class Mob {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.size = 20;
                this.health = 30;
                this.maxHealth = 30;
                this.speed = 1.0;
                this.damage = 5;
                this.lastAttackTime = 0;
                this.attackCooldown = 1500; // мс
                this.alive = true;
                this.color = type === 'zombie' ? '#2d5a27' : '#c0c0c0';
            }
            
            update(player, deltaTime) {
                if (!this.alive) return;
                
                // Движение к игроку
                const dx = player.x - this.x;
                const dy = player.y - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 0) {
                    this.x += (dx / distance) * this.speed;
                    this.y += (dy / distance) * this.speed;
                }
                
                // Обновление времени перезарядки атаки
                if (this.lastAttackTime > 0) {
                    this.lastAttackTime -= deltaTime;
                }
                
                // Проверка столкновения с игроком
                if (this.checkCollision(player) && this.lastAttackTime <= 0) {
                    player.takeDamage(this.damage);
                    this.lastAttackTime = this.attackCooldown;
                }
            }
            
            checkCollision(player) {
                const dx = this.x - player.x;
                const dy = this.y - player.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                return distance < (this.size / 2 + player.size / 2);
            }
            
            takeDamage(amount) {
                this.health -= amount;
                if (this.health <= 0) {
                    this.health = 0;
                    this.alive = false;
                    
                    // Дроп с моба (с шансом)
                    if (Math.random() < 0.3) { // 30% шанс
                        if (this.type === 'zombie') {
                            // Зомби дропает уголь
                            if (Math.random() < 0.5) {
                                game.player.inventory.addItem(ITEM_TYPES.COAL, 1);
                            }
                            
                            // 10% шанс выбить алтарь возрождения
                            if (Math.random() < 0.1) {
                                if (game.player.inventory.addItem(ITEM_TYPES.RESURRECTION_ALTAR, 1)) {
                                    game.showStatus('Получен: Алтарь возрождения! Установите для точки респавна.');
                                }
                            }
                        } else if (this.type === 'skeleton') {
                            // Скелет дропает камень
                            if (Math.random() < 0.5) {
                                game.player.inventory.addItem(ITEM_TYPES.STONE, 1);
                            }
                        }
                    }
                }
            }
            
            draw(ctx, camera, gameTime) {
                if (!this.alive) return;
                
                // Рисуем моба
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(
                    this.x - camera.x,
                    this.y - camera.y,
                    this.size / 2,
                    0,
                    Math.PI * 2
                );
                ctx.fill();
                
                // Глазы моба
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(
                    this.x - camera.x - 4,
                    this.y - camera.y - 4,
                    2,
                    0,
                    Math.PI * 2
                );
                ctx.fill();
                
                ctx.beginPath();
                ctx.arc(
                    this.x - camera.x + 4,
                    this.y - camera.y - 4,
                    2,
                    0,
                    Math.PI * 2
                );
                ctx.fill();
                
                // Зрачки
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(
                    this.x - camera.x - 4,
                    this.y - camera.y - 4,
                    1,
                    0,
                    Math.PI * 2
                );
                ctx.fill();
                
                ctx.beginPath();
                ctx.arc(
                    this.x - camera.x + 4,
                    this.y - camera.y - 4,
                    1,
                    0,
                    Math.PI * 2
                );
                ctx.fill();
                
                // Для скелетов добавляем лук
                if (this.type === 'skeleton') {
                    ctx.strokeStyle = '#8B4513';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(this.x - camera.x - 10, this.y - camera.y);
                    ctx.lineTo(this.x - camera.x + 10, this.y - camera.y);
                    ctx.stroke();
                }
                
                // Полоска здоровья
                const barWidth = 40;
                const barHeight = 4;
                const barX = this.x - camera.x - barWidth / 2;
                const barY = this.y - camera.y - this.size / 2 - 8;
                
                ctx.fillStyle = '#333';
                ctx.fillRect(barX, barY, barWidth, barHeight);
                
                const healthWidth = (this.health / this.maxHealth) * barWidth;
                ctx.fillStyle = this.health > 50 ? '#2ecc71' : this.health > 20 ? '#f39c12' : '#e74c3c';
                ctx.fillRect(barX, barY, healthWidth, barHeight);
            }
        }
        
        // ============================
        // СИСТЕМА ВРЕМЕНИ
        // ============================
        class GameTime {
            constructor() {
                this.currentTime = TIME_OF_DAY.DAY;
                this.timeElapsed = 0;
                this.dayCount = 0;
                this.lastTreeGrowthDay = 0;
                this.surfaceMobs = [];
                this.caveMobs = [];
                this.maxMobsPerLevel = 10;
                this.lastMobSpawnTime = 0;
                this.mobSpawnCooldown = 5000; // мс
            }
            
            update(deltaTime, world, player) {
                // Обновляем время
                this.timeElapsed += deltaTime;
                
                // Проверяем смену дня и ночи
                const cycleDuration = DAY_DURATION + NIGHT_DURATION;
                const cyclePosition = this.timeElapsed % cycleDuration;
                
                if (cyclePosition < DAY_DURATION) {
                    this.currentTime = TIME_OF_DAY.DAY;
                } else {
                    this.currentTime = TIME_OF_DAY.NIGHT;
                }
                
                // Обновляем счетчик дней
                const newDayCount = Math.floor(this.timeElapsed / cycleDuration);
                if (newDayCount > this.dayCount) {
                    this.dayCount = newDayCount;
                    
                    // Проверяем рост деревьев каждые 2 дня
                    if (this.dayCount - this.lastTreeGrowthDay >= DAYS_FOR_TREE_GROWTH) {
                        const treesGrown = world.growTrees();
                        if (treesGrown > 0) {
                            game.showStatus(`Выросли новые деревья (${treesGrown} шт.)!`);
                        }
                        this.lastTreeGrowthDay = this.dayCount;
                    }
                }
                
                // Обновляем время спавна мобов
                if (this.lastMobSpawnTime > 0) {
                    this.lastMobSpawnTime -= deltaTime;
                }
                
                // Спавн мобов ночью
                if (this.currentTime === TIME_OF_DAY.NIGHT && this.lastMobSpawnTime <= 0) {
                    this.spawnMobs(world, player);
                    this.lastMobSpawnTime = this.mobSpawnCooldown;
                }
                
                // Обновляем мобов на поверхности (только ночью)
                if (this.currentTime === TIME_OF_DAY.NIGHT) {
                    for (let i = this.surfaceMobs.length - 1; i >= 0; i--) {
                        const mob = this.surfaceMobs[i];
                        if (mob.alive && player.currentLevel === WORLD_LEVELS.SURFACE) {
                            mob.update(player, deltaTime);
                        }
                        
                        // Удаляем мертвых мобов
                        if (!mob.alive) {
                            this.surfaceMobs.splice(i, 1);
                        }
                    }
                    
                    // Убираем мобов с поверхности днем
                    if (this.currentTime === TIME_OF_DAY.DAY) {
                        this.surfaceMobs = [];
                    }
                }
                
                // Обновляем мобов в пещере (всегда, но только если игрок в пещере)
                for (let i = this.caveMobs.length - 1; i >= 0; i--) {
                    const mob = this.caveMobs[i];
                    if (mob.alive && player.currentLevel === WORLD_LEVELS.CAVE) {
                        mob.update(player, deltaTime);
                    }
                    
                    // Удаляем мертвых мобов
                    if (!mob.alive) {
                        this.caveMobs.splice(i, 1);
                    }
                }
            }
            
            spawnMobs(world, player) {
                // Спавн зомби на поверхности (только ночью)
                if (this.currentTime === TIME_OF_DAY.NIGHT && 
                    player.currentLevel === WORLD_LEVELS.SURFACE &&
                    this.surfaceMobs.length < this.maxMobsPerLevel) {
                    
                    // Пытаемся заспавнить 1-2 зомби
                    const mobsToSpawn = Math.floor(Math.random() * 2) + 1;
                    
                    for (let i = 0; i < mobsToSpawn; i++) {
                        if (this.surfaceMobs.length >= this.maxMobsPerLevel) break;
                        
                        let spawnX, spawnY;
                        let attempts = 0;
                        const maxAttempts = 20;
                        
                        do {
                            // Спавним моба на расстоянии от игрока
                            const angle = Math.random() * Math.PI * 2;
                            const distance = 200 + Math.random() * 200;
                            spawnX = player.x + Math.cos(angle) * distance;
                            spawnY = player.y + Math.sin(angle) * distance;
                            attempts++;
                            
                            // Проверяем, что позиция в пределах мира и не рядом с факелом
                            if (spawnX >= 0 && spawnX < WORLD_WIDTH * TILE_SIZE &&
                                spawnY >= 0 && spawnY < WORLD_HEIGHT * TILE_SIZE) {
                                
                                const tileType = world.getTileAt(spawnX, spawnY, WORLD_LEVELS.SURFACE);
                                const nearTorch = world.isPositionNearTorch(spawnX, spawnY, WORLD_LEVELS.SURFACE);
                                
                                if (tileType === TILE_TYPES.GRASS && !nearTorch) {
                                    break;
                                }
                            }
                        } while (attempts < maxAttempts);
                        
                        if (attempts < maxAttempts) {
                            const zombie = new Mob(spawnX, spawnY, 'zombie');
                            this.surfaceMobs.push(zombie);
                        }
                    }
                }
                
                // Спавн скелетов в пещере (всегда, когда игрок в пещере)
                if (player.currentLevel === WORLD_LEVELS.CAVE &&
                    this.caveMobs.length < this.maxMobsPerLevel) {
                    
                    // Пытаемся заспавнить 1 скелета
                    if (this.caveMobs.length < this.maxMobsPerLevel) {
                        let spawnX, spawnY;
                        let attempts = 0;
                        const maxAttempts = 30;
                        
                        do {
                            // Спавним моба на расстоянии от игрока в пещере
                            const angle = Math.random() * Math.PI * 2;
                            const distance = 150 + Math.random() * 150;
                            spawnX = player.x + Math.cos(angle) * distance;
                            spawnY = player.y + Math.sin(angle) * distance;
                            attempts++;
                            
                            // Проверяем, что позиция в пределах мира, на полу пещеры и не рядом с факелом
                            if (spawnX >= 0 && spawnX < WORLD_WIDTH * TILE_SIZE &&
                                spawnY >= 0 && spawnY < WORLD_HEIGHT * TILE_SIZE) {
                                
                                const tileType = world.getTileAt(spawnX, spawnY, WORLD_LEVELS.CAVE);
                                const nearTorch = world.isPositionNearTorch(spawnX, spawnY, WORLD_LEVELS.CAVE);
                                
                                if (tileType === CAVE_TILE_TYPES.CAVE_FLOOR && !nearTorch &&
                                    !player.isPositionInDarkness(spawnX, spawnY, world, this)) {
                                    break;
                                }
                            }
                        } while (attempts < maxAttempts);
                        
                        if (attempts < maxAttempts) {
                            const skeleton = new Mob(spawnX, spawnY, 'skeleton');
                            skeleton.speed = 0.8; // Скелеты медленнее
                            skeleton.damage = 8; // Но наносят больше урона
                            this.caveMobs.push(skeleton);
                        }
                    }
                }
            }
            
            draw(ctx, camera, player) {
                // Рисуем мобов на поверхности (только ночью и если игрок на поверхности)
                if (this.currentTime === TIME_OF_DAY.NIGHT && player.currentLevel === WORLD_LEVELS.SURFACE) {
                    for (const mob of this.surfaceMobs) {
                        if (mob.alive) {
                            mob.draw(ctx, camera, this);
                        }
                    }
                }
                
                // Рисуем мобов в пещере (только если игрок в пещере)
                if (player.currentLevel === WORLD_LEVELS.CAVE) {
                    for (const mob of this.caveMobs) {
                        if (mob.alive && !player.isPositionInDarkness(mob.x, mob.y, game.world, this)) {
                            mob.draw(ctx, camera, this);
                        }
                    }
                }
            }
            
            drawTimeIndicator(ctx) {
                // Индикатор времени суток
                const timeWidth = 150;
                const timeHeight = 20;
                const timeX = CANVAS_WIDTH - timeWidth - 20;
                const timeY = 20;
                
                // Фон индикатора
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(timeX, timeY, timeWidth, timeHeight);
                
                // Прогресс времени
                const cycleDuration = DAY_DURATION + NIGHT_DURATION;
                const cyclePosition = this.timeElapsed % cycleDuration;
                const progress = cyclePosition / cycleDuration;
                
                // Индикатор дня/ночи
                const dayWidth = DAY_DURATION / cycleDuration * timeWidth;
                
                // День
                ctx.fillStyle = '#FFD700';
                ctx.fillRect(timeX, timeY, dayWidth, timeHeight);
                
                // Ночь
                ctx.fillStyle = '#4169E1';
                ctx.fillRect(timeX + dayWidth, timeY, timeWidth - dayWidth, timeHeight);
                
                // Ползунок текущего времени
                const sliderX = timeX + progress * timeWidth;
                ctx.fillStyle = '#fff';
                ctx.fillRect(sliderX - 2, timeY - 5, 4, timeHeight + 10);
                
                // Текст
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 12px Courier New';
                ctx.textAlign = 'center';
                const timeText = this.currentTime === TIME_OF_DAY.DAY ? 'День' : 'Ночь';
                ctx.fillText(`${timeText} (День ${this.dayCount + 1})`, timeX + timeWidth/2, timeY + timeHeight + 15);
            }
        }
        
        // ============================
        // СИСТЕМА КРАФТА
        // ============================
        class CraftingSystem {
            constructor() {
                this.recipes = RECIPES;
                this.isOpen = false;
                this.scrollOffset = 0;
                this.maxScrollOffset = 0;
            }
            
            canCraft(recipe, inventory) {
                for (let ingredient of recipe.ingredients) {
                    if (!inventory.hasItems(ingredient.type, ingredient.count)) {
                        return false;
                    }
                }
                return true;
            }
            
            craft(recipe, inventory) {
                if (!this.canCraft(recipe, inventory)) return false;
                
                // Убираем ингредиенты
                for (let ingredient of recipe.ingredients) {
                    inventory.removeItem(ingredient.type, ingredient.count);
                }
                
                // Добавляем результат
                return inventory.addItem(recipe.result);
            }
            
            draw(ctx) {
                if (!this.isOpen) return;
                
                // Фон меню крафта
                ctx.fillStyle = 'rgba(0, 0, 0, 0.95)';
                ctx.fillRect(100, 80, CANVAS_WIDTH - 200, CANVAS_HEIGHT - 160);
                
                // Заголовок
                ctx.fillStyle = '#4af';
                ctx.font = 'bold 28px Courier New';
                ctx.textAlign = 'center';
                ctx.fillText('Крафт', CANVAS_WIDTH / 2, 120);
                
                // Область для рецептов
                const recipeAreaX = 120;
                const recipeAreaY = 150;
                const recipeAreaWidth = CANVAS_WIDTH - 240;
                const recipeAreaHeight = 350;
                const recipeHeight = 60;
                
                // Расчет максимального скролла
                const totalRecipesHeight = this.recipes.length * recipeHeight;
                this.maxScrollOffset = Math.max(0, totalRecipesHeight - recipeAreaHeight);
                
                // Область для отрисовки рецептов (с клиппингом)
                ctx.save();
                ctx.beginPath();
                ctx.rect(recipeAreaX, recipeAreaY, recipeAreaWidth, recipeAreaHeight);
                ctx.clip();
                
                // Фон области рецептов
                ctx.fillStyle = 'rgba(30, 30, 50, 0.8)';
                ctx.fillRect(recipeAreaX, recipeAreaY, recipeAreaWidth, recipeAreaHeight);
                
                // Рецепты
                const startY = recipeAreaY - this.scrollOffset;
                
                for (let i = 0; i < this.recipes.length; i++) {
                    const recipe = this.recipes[i];
                    const y = startY + i * recipeHeight;
                    
                    // Фон рецепта
                    const canCraft = this.canCraft(recipe, game.player.inventory);
                    ctx.fillStyle = canCraft ? 'rgba(50, 50, 70, 0.8)' : 'rgba(70, 30, 30, 0.8)';
                    ctx.fillRect(recipeAreaX + 10, y + 5, recipeAreaWidth - 20, recipeHeight - 10);
                    
                    // Название рецепта
                    ctx.fillStyle = canCraft ? '#8cf' : '#f88';
                    ctx.font = 'bold 18px Courier New';
                    ctx.textAlign = 'left';
                    ctx.fillText(recipe.name, recipeAreaX + 30, y + 30);
                    
                    // Ингредиенты
                    ctx.fillStyle = canCraft ? '#ccc' : '#aaa';
                    ctx.font = '14px Courier New';
                    let ingredientText = '';
                    for (let j = 0; j < recipe.ingredients.length; j++) {
                        const ing = recipe.ingredients[j];
                        ingredientText += `${ing.count}x ${ITEM_NAMES[ing.type]}`;
                        if (j < recipe.ingredients.length - 1) ingredientText += ', ';
                    }
                    ctx.fillText(ingredientText, recipeAreaX + 30, y + 50);
                    
                    // Результат
                    ctx.fillStyle = ITEM_COLORS[recipe.result];
                    ctx.fillRect(CANVAS_WIDTH - 250, y + 10, 40, 40);
                    ctx.fillStyle = '#fff';
                    ctx.textAlign = 'center';
                    ctx.fillText(ITEM_NAMES[recipe.result], CANVAS_WIDTH - 230, y + 60);
                    
                    // Подсветка при наведении
                    const mouseInRecipe = game.mouse.x >= recipeAreaX + 10 && 
                                         game.mouse.x <= recipeAreaX + recipeAreaWidth - 10 && 
                                         game.mouse.y >= y + 5 && 
                                         game.mouse.y <= y + recipeHeight - 5;
                    
                    if (mouseInRecipe) {
                        ctx.strokeStyle = canCraft ? '#4af' : '#f44';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(recipeAreaX + 10, y + 5, recipeAreaWidth - 20, recipeHeight - 10);
                        
                        // Клик для крафта
                        if (game.mouse.clicked && canCraft) {
                            if (this.craft(recipe, game.player.inventory)) {
                                game.mouse.clicked = false;
                                game.showStatus(`Создан: ${ITEM_NAMES[recipe.result]}`);
                            }
                        }
                    }
                }
                
                ctx.restore();
                
                // Полоса прокрутки (если нужно)
                if (totalRecipesHeight > recipeAreaHeight) {
                    const scrollbarWidth = 10;
                    const scrollbarX = recipeAreaX + recipeAreaWidth - scrollbarWidth - 5;
                    const scrollbarHeight = recipeAreaHeight;
                    const thumbHeight = (recipeAreaHeight / totalRecipesHeight) * scrollbarHeight;
                    const thumbY = recipeAreaY + (this.scrollOffset / totalRecipesHeight) * scrollbarHeight;
                    
                    // Фон полосы прокрутки
                    ctx.fillStyle = 'rgba(100, 100, 120, 0.5)';
                    ctx.fillRect(scrollbarX, recipeAreaY, scrollbarWidth, scrollbarHeight);
                    
                    // Ползунок
                    ctx.fillStyle = '#4af';
                    ctx.fillRect(scrollbarX, thumbY, scrollbarWidth, thumbHeight);
                    
                    // Контур ползунка
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(scrollbarX, thumbY, scrollbarWidth, thumbHeight);
                    
                    // Обработка клика по полосе прокрутки
                    if (game.mouse.clicked && 
                        game.mouse.x >= scrollbarX && 
                        game.mouse.x <= scrollbarX + scrollbarWidth && 
                        game.mouse.y >= recipeAreaY && 
                        game.mouse.y <= recipeAreaY + scrollbarHeight) {
                        
                        const clickPosition = game.mouse.y - recipeAreaY;
                        const newScrollOffset = (clickPosition / scrollbarHeight) * totalRecipesHeight;
                        this.scrollOffset = Math.max(0, Math.min(newScrollOffset, this.maxScrollOffset));
                    }
                }
                
                // Подсказки
                ctx.fillStyle = '#aaa';
                ctx.font = '14px Courier New';
                ctx.textAlign = 'center';
                ctx.fillText('Используйте колесо мыши для прокрутки', CANVAS_WIDTH / 2, CANVAS_HEIGHT - 100);
                ctx.fillText('Нажмите ESC для закрытия', CANVAS_WIDTH / 2, CANVAS_HEIGHT - 80);
            }
            
            handleWheel(deltaY) {
                if (!this.isOpen) return;
                
                this.scrollOffset += deltaY * 0.5;
                this.scrollOffset = Math.max(0, Math.min(this.scrollOffset, this.maxScrollOffset));
            }
        }
        
        // ============================
        // КАМЕРА
        // ============================
        class Camera {
            constructor() {
                this.x = 0;
                this.y = 0;
            }
            
            update(player) {
                // Центрируем камеру на игроке
                this.x = player.x - CANVAS_WIDTH / 2;
                this.y = player.y - CANVAS_HEIGHT / 2;
                
                // Ограничиваем камеру в пределах мира
                this.x = Math.max(0, Math.min(this.x, WORLD_WIDTH * TILE_SIZE - CANVAS_WIDTH));
                this.y = Math.max(0, Math.min(this.y, WORLD_HEIGHT * TILE_SIZE - CANVAS_HEIGHT));
            }
        }
        
        // ============================
        // ОСНОВНАЯ ИГРА
        // ============================
        class Game {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.world = new World();
                this.player = new Player();
                this.craftingSystem = new CraftingSystem();
                this.camera = new Camera();
                this.gameTime = new GameTime();
                this.boss = null;
                this.caveBoss = null;
                this.bossSpawned = false;
                this.caveBossSpawned = false;
                this.gameOver = false;
                this.lastTime = 0;
                this.showSmeltHint = false;
                this.showLevelChangeHint = false;
                
                // Управление
                this.keys = {};
                this.mouse = {
                    x: 0,
                    y: 0,
                    clicked: false
                };
                
                // Статусное сообщение
                this.statusMessage = '';
                this.statusTimer = 0;
                
                // Инициализация обработчиков событий
                this.initEventListeners();
                
                // Запуск игрового цикла
                requestAnimationFrame(this.gameLoop.bind(this));
            }
            
            initEventListeners() {
                // Клавиатура
                document.addEventListener('keydown', (e) => {
                    this.keys[e.code] = true;
                    
                    // Выбор слота инвентаря (1-0)
                    if (e.code >= 'Digit1' && e.code <= 'Digit9') {
                        const slotIndex = parseInt(e.code[5]) - 1;
                        if (slotIndex >= 0 && slotIndex < this.player.inventory.slots.length) {
                            this.player.selectedSlot = slotIndex;
                        }
                    }
                    if (e.code === 'Digit0') {
                        this.player.selectedSlot = 9;
                    }
                    
                    // Открытие/закрытие меню крафта
                    if (e.code === 'KeyC') {
                        this.craftingSystem.isOpen = !this.craftingSystem.isOpen;
                        // Сбрасываем скролл при открытии меню
                        if (this.craftingSystem.isOpen) {
                            this.craftingSystem.scrollOffset = 0;
                        }
                    }
                    
                    // Закрытие меню крафта
                    if (e.code === 'Escape') {
                        this.craftingSystem.isOpen = false;
                    }
                    
                    // Сбор ресурсов
                    if (e.code === 'KeyE') {
                        this.collectResourceWithE();
                    }
                    
                    // Плавка руды
                    if (e.code === 'KeyF') {
                        this.smeltOre();
                    }
                    
                    // Смена уровня (спуск/подъем)
                    if (e.code === 'Space') {
                        this.changeLevel();
                    }
                });
                
                document.addEventListener('keyup', (e) => {
                    this.keys[e.code] = false;
                });
                
                // Мышь
                this.canvas.addEventListener('mousemove', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    this.mouse.x = e.clientX - rect.left;
                    this.mouse.y = e.clientY - rect.top;
                });
                
                this.canvas.addEventListener('mousedown', (e) => {
                    if (e.button === 0) { // Левая кнопка мыши
                        this.mouse.clicked = true;
                        
                        // Если открыто меню крафта, клик обрабатывается там
                        if (!this.craftingSystem.isOpen) {
                            const selectedItem = this.player.inventory.getSelectedItem();
                            
                            // Использование магического скипетра для стрельбы снарядами
                            if (selectedItem.type === ITEM_TYPES.MAGIC_SCEPTER) {
                                const worldX = this.mouse.x + this.camera.x;
                                const worldY = this.mouse.y + this.camera.y;
                                this.player.shootMagicProjectile(worldX, worldY);
                                return;
                            }
                            
                            // Использование молота или железного молота для атаки
                            const canAttackWithHammer = selectedItem.type === ITEM_TYPES.HAMMER || 
                                                       selectedItem.type === ITEM_TYPES.IRON_HAMMER;
                            
                            if (canAttackWithHammer && this.player.canAttack()) {
                                const worldX = this.mouse.x + this.camera.x;
                                const worldY = this.mouse.y + this.camera.y;
                                
                                // Проверяем босса на поверхности
                                if (this.player.currentLevel === WORLD_LEVELS.SURFACE && 
                                    this.boss && this.boss.alive) {
                                    const dx = worldX - this.boss.x;
                                    const dy = worldY - this.boss.y;
                                    const distance = Math.sqrt(dx * dx + dy * dy);
                                    
                                    if (distance < 100) {
                                        const damage = selectedItem.type === ITEM_TYPES.IRON_HAMMER ? 30 : 20;
                                        this.boss.takeDamage(damage);
                                        this.player.attack();
                                        this.showStatus('Босс атакован!');
                                        
                                        if (!this.boss.alive) {
                                            this.showStatus('Босс поверхности побежден! Получена улучшенная кирка!');
                                        }
                                        return;
                                    }
                                }
                                
                                // Проверяем пещерного босса
                                if (this.player.currentLevel === WORLD_LEVELS.CAVE && 
                                    this.caveBoss && this.caveBoss.alive) {
                                    const dx = worldX - this.caveBoss.x;
                                    const dy = worldY - this.caveBoss.y;
                                    const distance = Math.sqrt(dx * dx + dy * dy);
                                    
                                    if (distance < 120) { // Больший радиус для пещерного босса
                                        const damage = selectedItem.type === ITEM_TYPES.IRON_HAMMER ? 35 : 25;
                                        this.caveBoss.takeDamage(damage);
                                        this.player.attack();
                                        this.showStatus('Пещерный босс атакован!');
                                        
                                        if (!this.caveBoss.alive) {
                                            this.showStatus('Пещерный босс побежден! Получен волшебный скипетр!');
                                        }
                                        return;
                                    }
                                }
                                
                                // Атака мобов молотом (только если рядом)
                                const attackRadius = 60;
                                let attackedMob = false;
                                
                                // Проверяем мобов на поверхности
                                if (this.player.currentLevel === WORLD_LEVELS.SURFACE) {
                                    for (let zombie of this.gameTime.surfaceMobs) {
                                        if (zombie.alive) {
                                            const dx = worldX - zombie.x;
                                            const dy = worldY - zombie.y;
                                            const distance = Math.sqrt(dx * dx + dy * dy);
                                            
                                            if (distance < attackRadius) {
                                                const damage = selectedItem.type === ITEM_TYPES.IRON_HAMMER ? 25 : 15;
                                                zombie.takeDamage(damage);
                                                this.player.attack();
                                                attackedMob = true;
                                                break;
                                            }
                                        }
                                    }
                                }
                                
                                // Проверяем мобов в пещере
                                if (this.player.currentLevel === WORLD_LEVELS.CAVE) {
                                    for (let skeleton of this.gameTime.caveMobs) {
                                        if (skeleton.alive) {
                                            const dx = worldX - skeleton.x;
                                            const dy = worldY - skeleton.y;
                                            const distance = Math.sqrt(dx * dx + dy * dy);
                                            
                                            if (distance < attackRadius) {
                                                const damage = selectedItem.type === ITEM_TYPES.IRON_HAMMER ? 25 : 15;
                                                skeleton.takeDamage(damage);
                                                this.player.attack();
                                                attackedMob = true;
                                                break;
                                            }
                                        }
                                    }
                                }
                                
                                if (attackedMob) {
                                    this.showStatus('Моб атакован!');
                                    return;
                                }
                                
                                // Если никого не атаковали, просто используем атаку (например, для разрушения чего-то в будущем)
                                this.player.attack();
                                this.showStatus('Атака!');
                                return;
                            }
                            
                            // Использование улучшенной кирки
                            if (selectedItem.type === ITEM_TYPES.IMPROVED_PICKAXE) {
                                this.useImprovedPickaxe();
                                return;
                            }
                            
                            // Использование инструментов на ЛКМ
                            // Использование лопаты для создания шахты
                            if (selectedItem.type === ITEM_TYPES.SHOVEL && this.player.currentLevel === WORLD_LEVELS.SURFACE) {
                                this.useShovel();
                                return;
                            }
                            
                            // Использование кирки для добычи в пещере
                            if (selectedItem.type === ITEM_TYPES.PICKAXE && this.player.currentLevel === WORLD_LEVELS.CAVE) {
                                this.usePickaxe();
                                return;
                            }
                            
                            // Строительство (для других предметов)
                            this.placeBuilding();
                        }
                    }
                });
                
                this.canvas.addEventListener('mouseup', (e) => {
                    if (e.button === 0) {
                        this.mouse.clicked = false;
                    }
                });
                
                // Колесо мыши для выбора слота инвентаря и прокрутки меню крафта
                this.canvas.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    
                    // Если открыто меню крафта, прокручиваем его
                    if (this.craftingSystem.isOpen) {
                        this.craftingSystem.handleWheel(e.deltaY);
                        return;
                    }
                    
                    // Иначе меняем выбранный слот инвентаря
                    if (e.deltaY > 0) {
                        this.player.selectedSlot = (this.player.selectedSlot + 1) % this.player.inventory.slots.length;
                    } else {
                        this.player.selectedSlot = (this.player.selectedSlot - 1 + this.player.inventory.slots.length) % this.player.inventory.slots.length;
                    }
                });
            }
            
            collectResourceWithE() {
                const playerCenterX = this.player.x + this.player.size / 2;
                const playerCenterY = this.player.y + this.player.size / 2;
                
                // Проверяем ресурсы вокруг игрока (только на поверхности)
                if (this.player.currentLevel === WORLD_LEVELS.SURFACE) {
                    const checkRadius = TILE_SIZE * 1.5;
                    
                    for (let dx = -checkRadius; dx <= checkRadius; dx += TILE_SIZE) {
                        for (let dy = -checkRadius; dy <= checkRadius; dy += TILE_SIZE) {
                            const checkX = playerCenterX + dx;
                            const checkY = playerCenterY + dy;
                            
                            // Проверяем, есть ли дерево или камень
                            const tileType = this.world.getTileAt(checkX, checkY, this.player.currentLevel);
                            if (tileType === TILE_TYPES.STONE || tileType === TILE_TYPES.TREE) {
                                const resourceType = this.world.collectResource(checkX, checkY, this.player.currentLevel, null);
                                if (resourceType !== ITEM_TYPES.NONE) {
                                    const itemName = ITEM_NAMES[resourceType];
                                    if (this.player.inventory.addItem(resourceType)) {
                                        this.showStatus(`Собрано: ${itemName}`);
                                    } else {
                                        this.showStatus('Инвентарь полон!');
                                    }
                                }
                                return;
                            }
                        }
                    }
                    
                    this.showStatus('Рядом нет ресурсов для сбора!');
                } else {
                    this.showStatus('В пещере используйте кирку (ЛКМ) для добычи!');
                }
            }
            
            useShovel() {
                // Использование лопаты для создания шахты
                const worldX = this.mouse.x + this.camera.x;
                const worldY = this.mouse.y + this.camera.y;
                
                // Проверяем, можно ли создать шахту здесь
                const tileType = this.world.getTileAt(worldX, worldY, this.player.currentLevel);
                if (tileType === TILE_TYPES.GRASS) {
                    if (this.world.createMineShaft(worldX, worldY)) {
                        this.showStatus('Шахта создана! Используйте ПРОБЕЛ рядом с шахтой, чтобы спуститься в пещеру.');
                    } else {
                        this.showStatus('Невозможно создать шахту здесь!');
                    }
                } else {
                    this.showStatus('Шахту можно создать только на траве!');
                }
            }
            
            usePickaxe() {
                // Использование кирки для добычи в пещере
                const worldX = this.mouse.x + this.camera.x;
                const worldY = this.mouse.y + this.camera.y;
                
                // Проверяем, находится ли позиция в темноте
                if (this.player.isPositionInDarkness(worldX, worldY, this.world, this.gameTime)) {
                    this.showStatus('Слишком темно! Подойдите ближе или поставьте факел.');
                    return;
                }
                
                // Проверяем, можно ли добыть здесь
                const tileType = this.world.getTileAt(worldX, worldY, this.player.currentLevel);
                const canMine = tileType === CAVE_TILE_TYPES.CAVE_WALL || 
                               tileType === CAVE_TILE_TYPES.IRON_ORE || 
                               tileType === CAVE_TILE_TYPES.COAL_ORE;
                
                if (canMine) {
                    const resourceType = this.world.collectResource(worldX, worldY, this.player.currentLevel, ITEM_TYPES.PICKAXE);
                    if (resourceType !== ITEM_TYPES.NONE) {
                        const itemName = ITEM_NAMES[resourceType];
                        if (this.player.inventory.addItem(resourceType)) {
                            this.showStatus(`Добыто: ${itemName}`);
                        } else {
                            this.showStatus('Инвентарь полон!');
                        }
                    }
                } else {
                    this.showStatus('Здесь нечего добывать!');
                }
            }
            
            useImprovedPickaxe() {
                // Использование улучшенной кирки
                const worldX = this.mouse.x + this.camera.x;
                const worldY = this.mouse.y + this.camera.y;
                
                // Проверяем, находится ли позиция в темноте (только для пещеры)
                if (this.player.currentLevel === WORLD_LEVELS.CAVE && 
                    this.player.isPositionInDarkness(worldX, worldY, this.world, this.gameTime)) {
                    this.showStatus('Слишком темно! Подойдите ближе или поставьте факел.');
                    return;
                }
                
                // Проверяем, можно ли разрушить алтарь
                const altarType = this.world.breakAltar(worldX, worldY, this.player.currentLevel);
                if (altarType !== ITEM_TYPES.NONE) {
                    // Возвращаем алтарь в инвентарь
                    if (this.player.inventory.addItem(altarType, 1)) {
                        const itemName = ITEM_NAMES[altarType];
                        this.showStatus(`Алтарь разрушен! Возвращено: ${itemName}`);
                    } else {
                        this.showStatus('Инвентарь полон!');
                    }
                    return;
                }
                
                // Если в пещере, копаем область 3x3
                if (this.player.currentLevel === WORLD_LEVELS.CAVE) {
                    const minedItems = this.world.digArea(worldX, worldY, this.player.currentLevel);
                    if (minedItems.length > 0) {
                        let itemsAdded = 0;
                        for (const itemType of minedItems) {
                            if (this.player.inventory.addItem(itemType, 1)) {
                                itemsAdded++;
                            }
                        }
                        if (itemsAdded > 0) {
                            this.showStatus(`Улучшенная кирка добыла ${itemsAdded} ресурсов!`);
                        } else {
                            this.showStatus('Инвентарь полон!');
                        }
                    } else {
                        this.showStatus('Здесь нечего добывать!');
                    }
                } else {
                    this.showStatus('Улучшенная кирка работает только в пещере!');
                }
            }
            
            placeBuilding() {
                const selectedItem = this.player.inventory.getSelectedItem();
                
                // Проверяем, можно ли разместить этот предмет
                const placeableItems = [
                    ITEM_TYPES.WALL, ITEM_TYPES.ALTAR, ITEM_TYPES.FURNACE, 
                    ITEM_TYPES.LADDER, ITEM_TYPES.TORCH, ITEM_TYPES.RESURRECTION_ALTAR
                ];
                
                if (placeableItems.includes(selectedItem.type)) {
                    // Вычисляем координаты в мире
                    const worldX = this.mouse.x + this.camera.x;
                    const worldY = this.mouse.y + this.camera.y;
                    
                    // В пещере и ночью на поверхности проверяем, не в темноте ли место
                    if ((this.player.currentLevel === WORLD_LEVELS.CAVE || 
                        (this.player.currentLevel === WORLD_LEVELS.SURFACE && 
                         this.gameTime.currentTime === TIME_OF_DAY.NIGHT)) && 
                        this.player.isPositionInDarkness(worldX, worldY, this.world, this.gameTime)) {
                        this.showStatus('Слишком темно для строительства! Поставьте факел рядом.');
                        return;
                    }
                    
                    // Проверяем, что игрок не пытается построить слишком далеко
                    const playerCenterX = this.player.x + this.player.size / 2;
                    const playerCenterY = this.player.y + this.player.size / 2;
                    const distance = Math.sqrt(
                        Math.pow(worldX - playerCenterX, 2) + 
                        Math.pow(worldY - playerCenterY, 2)
                    );
                    
                    if (distance > TILE_SIZE * 5) {
                        this.showStatus('Слишком далеко для строительства!');
                        return;
                    }
                    
                    // Сохраняем тип предмета до удаления из инвентаря
                    const itemType = selectedItem.type;
                    
                    // Размещаем предмет
                    if (this.world.placeTile(worldX, worldY, itemType, this.player.currentLevel)) {
                        // Убираем предмет из инвентаря
                        if (this.player.inventory.removeItem(itemType, 1)) {
                            const itemName = ITEM_NAMES[itemType];
                            this.showStatus(`Построено: ${itemName}`);
                            
                            // Если построен алтарь возрождения, устанавливаем точку возрождения
                            if (itemType === ITEM_TYPES.RESURRECTION_ALTAR) {
                                const tileX = Math.floor(worldX / TILE_SIZE);
                                const tileY = Math.floor(worldY / TILE_SIZE);
                                this.player.setRespawnPoint(
                                    tileX * TILE_SIZE + TILE_SIZE/2,
                                    tileY * TILE_SIZE + TILE_SIZE/2,
                                    this.player.currentLevel
                                );
                                this.showStatus('Точка возрождения установлена!');
                            }
                            
                            // Если построен алтарь, спауним соответствующего босса
                            if (itemType === ITEM_TYPES.ALTAR) {
                                if (this.player.currentLevel === WORLD_LEVELS.SURFACE && !this.bossSpawned) {
                                    this.spawnBoss();
                                } else if (this.player.currentLevel === WORLD_LEVELS.CAVE && !this.caveBossSpawned) {
                                    this.spawnCaveBoss();
                                }
                            }
                        } else {
                            // Если не удалось удалить предмет из инвентаря, удаляем построенный тайл
                            const tileX = Math.floor(worldX / TILE_SIZE);
                            const tileY = Math.floor(worldY / TILE_SIZE);
                            if (this.player.currentLevel === WORLD_LEVELS.SURFACE) {
                                this.world.surfacePlacedTiles.delete(`${tileX},${tileY}`);
                            } else {
                                this.world.cavePlacedTiles.delete(`${tileX},${tileY}`);
                            }
                            this.showStatus('Недостаточно предметов для строительства!');
                        }
                    } else {
                        this.showStatus('Невозможно построить здесь!');
                    }
                } else if (selectedItem.type !== ITEM_TYPES.NONE && 
                          selectedItem.type !== ITEM_TYPES.SHOVEL && 
                          selectedItem.type !== ITEM_TYPES.PICKAXE &&
                          selectedItem.type !== ITEM_TYPES.MAGIC_SCEPTER &&
                          selectedItem.type !== ITEM_TYPES.IMPROVED_PICKAXE) {
                    this.showStatus('Этот предмет нельзя построить!');
                }
            }
            
            smeltOre() {
                // Проверяем, рядом ли печка
                if (this.world.isNearFurnace(this.player.x + this.player.size/2, 
                    this.player.y + this.player.size/2, this.player.currentLevel)) {
                    
                    // Проверяем, может ли игрок плавить
                    if (this.player.canSmelt()) {
                        // Проверяем наличие угля и железной руды
                        const coalCount = this.player.inventory.getItemCount(ITEM_TYPES.COAL);
                        const ironOreCount = this.player.inventory.getItemCount(ITEM_TYPES.IRON_ORE);
                        
                        if (coalCount >= 1 && ironOreCount >= 1) {
                            // Плавим железную руду
                            this.player.inventory.removeItem(ITEM_TYPES.COAL, 1);
                            this.player.inventory.removeItem(ITEM_TYPES.IRON_ORE, 1);
                            this.player.inventory.addItem(ITEM_TYPES.IRON_BAR, 1);
                            
                            this.player.smelt();
                            this.showStatus('Плавка: создан железный слиток!');
                        } else {
                            this.showStatus('Нужны уголь и железная руда для плавки!');
                        }
                    } else {
                        this.showStatus('Подождите перед следующей плавкой!');
                    }
                } else {
                    this.showStatus('Подойдите к печке для плавки!');
                }
            }
            
            changeLevel() {
                // Проверяем, рядом ли шахта или лестница
                if (this.world.isNearMineShaftOrLadder(this.player.x + this.player.size/2, 
                    this.player.y + this.player.size/2, this.player.currentLevel)) {
                    
                    if (this.player.currentLevel === WORLD_LEVELS.SURFACE) {
                        // Спускаемся в пещеру
                        this.player.currentLevel = WORLD_LEVELS.CAVE;
                        // Помещаем игрока в центр пещеры (рядом с лестницей на поверхность)
                        this.player.x = Math.floor(WORLD_WIDTH / 2) * TILE_SIZE;
                        this.player.y = Math.floor(WORLD_HEIGHT / 2) * TILE_SIZE;
                        // Ищем свободное место рядом с лестницей
                        let foundSpot = false;
                        for (let dy = -1; dy <= 1 && !foundSpot; dy++) {
                            for (let dx = -1; dx <= 1 && !foundSpot; dx++) {
                                if (dx === 0 && dy === 0) continue;
                                const newX = this.player.x + dx * TILE_SIZE;
                                const newY = this.player.y + dy * TILE_SIZE;
                                if (!this.player.checkCollision(newX, newY, this.world)) {
                                    this.player.x = newX;
                                    this.player.y = newY;
                                    foundSpot = true;
                                }
                            }
                        }
                        this.showStatus('Вы спустились в пещеру! Используйте кирку (ЛКМ) для добычи руды.');
                    } else {
                        // Поднимаемся на поверхность
                        this.player.currentLevel = WORLD_LEVELS.SURFACE;
                        
                        // Находим ближайшую шахту для выхода
                        let foundShaft = false;
                        for (let [key, itemType] of this.world.surfacePlacedTiles) {
                            if (itemType === ITEM_TYPES.MINE_SHAFT) {
                                const [x, y] = key.split(',').map(Number);
                                // Помещаем игрока рядом с шахтой, а не на ней
                                this.player.x = x * TILE_SIZE + TILE_SIZE;
                                this.player.y = y * TILE_SIZE;
                                
                                // Ищем свободное место рядом с шахтой
                                let foundSpot = false;
                                for (let dy = -1; dy <= 1 && !foundSpot; dy++) {
                                    for (let dx = -1; dx <= 1 && !foundSpot; dx++) {
                                        if (dx === 0 && dy === 0) continue;
                                        const newX = this.player.x + dx * TILE_SIZE;
                                        const newY = this.player.y + dy * TILE_SIZE;
                                        if (!this.player.checkCollision(newX, newY, this.world)) {
                                            this.player.x = newX;
                                            this.player.y = newY;
                                            foundSpot = true;
                                        }
                                    }
                                }
                                foundShaft = true;
                                break;
                            }
                        }
                        
                        // Если не нашли шахту, выходим в центр мира
                        if (!foundShaft) {
                            this.player.x = Math.floor(WORLD_WIDTH / 2) * TILE_SIZE;
                            this.player.y = Math.floor(WORLD_HEIGHT / 2) * TILE_SIZE;
                            // Ищем свободное место
                            let foundSpot = false;
                            for (let dy = -1; dy <= 1 && !foundSpot; dy++) {
                                for (let dx = -1; dx <= 1 && !foundSpot; dx++) {
                                    if (dx === 0 && dy === 0) continue;
                                    const newX = this.player.x + dx * TILE_SIZE;
                                    const newY = this.player.y + dy * TILE_SIZE;
                                    if (!this.player.checkCollision(newX, newY, this.world)) {
                                        this.player.x = newX;
                                        this.player.y = newY;
                                        foundSpot = true;
                                    }
                                }
                            }
                        }
                        this.showStatus('Вы поднялись на поверхность!');
                    }
                } else {
                    this.showStatus('Подойдите к шахте или лестнице!');
                }
            }
            
            spawnBoss() {
                // Спауним босса в случайном месте, но не слишком близко к игроку
                let spawnX, spawnY;
                let attempts = 0;
                const maxAttempts = 20;
                
                do {
                    spawnX = Math.random() * (WORLD_WIDTH * TILE_SIZE - 200) + 100;
                    spawnY = Math.random() * (WORLD_HEIGHT * TILE_SIZE - 200) + 100;
                    attempts++;
                    
                    // Проверяем расстояние до игрока
                    const dx = spawnX - this.player.x;
                    const dy = spawnY - this.player.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance > TILE_SIZE * 10) {
                        break;
                    }
                } while (attempts < maxAttempts);
                
                this.boss = new Boss(spawnX, spawnY);
                this.bossSpawned = true;
                this.showStatus('БОСС ПОВЕРХНОСТИ ПОЯВИЛСЯ! Приготовьтесь к битве!');
            }
            
            spawnCaveBoss() {
                // Спауним пещерного босса в пещере
                let spawnX, spawnY;
                let attempts = 0;
                const maxAttempts = 30;
                
                do {
                    spawnX = Math.random() * (WORLD_WIDTH * TILE_SIZE - 200) + 100;
                    spawnY = Math.random() * (WORLD_HEIGHT * TILE_SIZE - 200) + 100;
                    attempts++;
                    
                    // Проверяем, что позиция в пещере (на полу) и не слишком близко к игроку
                    const tileType = this.world.getTileAt(spawnX, spawnY, WORLD_LEVELS.CAVE);
                    const dx = spawnX - this.player.x;
                    const dy = spawnY - this.player.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (tileType === CAVE_TILE_TYPES.CAVE_FLOOR && distance > TILE_SIZE * 8) {
                        // Проверяем, нет ли препятствий вокруг
                        let clearArea = true;
                        for (let dy = -2; dy <= 2 && clearArea; dy++) {
                            for (let dx = -2; dx <= 2 && clearArea; dx++) {
                                const checkX = spawnX + dx * TILE_SIZE;
                                const checkY = spawnY + dy * TILE_SIZE;
                                const checkTile = this.world.getTileAt(checkX, checkY, WORLD_LEVELS.CAVE);
                                if (checkTile !== CAVE_TILE_TYPES.CAVE_FLOOR) {
                                    clearArea = false;
                                }
                            }
                        }
                        
                        if (clearArea) {
                            break;
                        }
                    }
                } while (attempts < maxAttempts);
                
                this.caveBoss = new CaveBoss(spawnX, spawnY);
                this.caveBossSpawned = true;
                this.showStatus('ПЕЩЕРНЫЙ БОСС ПОЯВИЛСЯ! Остерегайтесь его снарядов!');
            }
            
            showStatus(message) {
                this.statusMessage = message;
                this.statusTimer = 180; // ~3 секунды при 60 FPS
                document.getElementById('status').textContent = message;
            }
            
            update(deltaTime) {
                // Если игра окончена, не обновляем
                if (this.gameOver) return;
                
                // Обновляем время игры
                this.gameTime.update(deltaTime, this.world, this.player);
                
                // Обновляем игрока
                this.player.update(this.keys, this.world, deltaTime, this.gameTime);
                
                // Обновляем камеру
                this.camera.update(this.player);
                
                // Обновляем босса поверхности
                if (this.boss && this.boss.alive && this.player.currentLevel === WORLD_LEVELS.SURFACE) {
                    this.boss.update(this.player, deltaTime);
                }
                
                // Обновляем пещерного босса
                if (this.caveBoss && this.caveBoss.alive && this.player.currentLevel === WORLD_LEVELS.CAVE) {
                    this.caveBoss.update(this.player, deltaTime);
                }
                
                // Проверяем смерть игрока
                if (this.player.health <= 0) {
                    // Возрождаем игрока
                    this.player.respawn();
                    this.showStatus('Вы возродились у алтаря возрождения!');
                }
                
                // Проверяем, рядом ли печка
                this.showSmeltHint = this.world.isNearFurnace(
                    this.player.x + this.player.size/2, 
                    this.player.y + this.player.size/2, 
                    this.player.currentLevel
                );
                
                // Проверяем, рядом ли шахта/лестница
                this.showLevelChangeHint = this.world.isNearMineShaftOrLadder(
                    this.player.x + this.player.size/2, 
                    this.player.y + this.player.size/2, 
                    this.player.currentLevel
                );
                
                // Обновляем таймер статусного сообщения
                if (this.statusTimer > 0) {
                    this.statusTimer--;
                }
            }
            
            draw() {
                // Очистка canvas
                this.ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                
                // Рисуем мир (текущий уровень)
                this.world.draw(this.ctx, this.camera, this.player.currentLevel, this.gameTime);
                
                // Рисуем босса поверхности (только на поверхности)
                if (this.boss && this.boss.alive && this.player.currentLevel === WORLD_LEVELS.SURFACE) {
                    this.boss.draw(this.ctx, this.camera);
                }
                
                // Рисуем пещерного босса (только в пещере)
                if (this.caveBoss && this.caveBoss.alive && this.player.currentLevel === WORLD_LEVELS.CAVE) {
                    this.caveBoss.draw(this.ctx, this.camera);
                }
                
                // Рисуем мобов
                this.gameTime.draw(this.ctx, this.camera, this.player);
                
                // Рисуем игрока
                this.player.draw(this.ctx, this.camera, this.gameTime);
                
                // Рисуем интерфейс
                this.player.drawHealthBar(this.ctx);
                this.player.drawLevelIndicator(this.ctx, this.gameTime);
                this.player.inventory.draw(this.ctx);
                this.gameTime.drawTimeIndicator(this.ctx);
                
                // Рисуем меню крафта
                this.craftingSystem.draw(this.ctx);
                
                // Рисуем экран поражения (удалено, теперь игрок возрождается)
                
                // Рисуем подсказки
                if (this.showSmeltHint && !this.craftingSystem.isOpen) {
                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    this.ctx.fillRect(CANVAS_WIDTH/2 - 150, 60, 300, 30);
                    
                    this.ctx.fillStyle = '#FFD700';
                    this.ctx.font = 'bold 16px Courier New';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText('Нажмите F для плавки руды в печке', CANVAS_WIDTH/2, 80);
                }
                
                if (this.showLevelChangeHint && !this.craftingSystem.isOpen) {
                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    this.ctx.fillRect(CANVAS_WIDTH/2 - 150, 100, 300, 30);
                    
                    const hintText = this.player.currentLevel === WORLD_LEVELS.SURFACE ? 
                        'Нажмите ПРОБЕЛ чтобы спуститься в пещеру' : 
                        'Нажмите ПРОБЕЛ чтобы подняться на поверхность';
                    
                    this.ctx.fillStyle = '#4af';
                    this.ctx.font = 'bold 16px Courier New';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText(hintText, CANVAS_WIDTH/2, 120);
                }
                
                // Рисуем прицел для инструментов и оружия
                if (!this.craftingSystem.isOpen) {
                    const selectedItem = this.player.inventory.getSelectedItem();
                    const ctx = this.ctx;
                    
                    // Прицел для лопаты на поверхности
                    if (selectedItem.type === ITEM_TYPES.SHOVEL && this.player.currentLevel === WORLD_LEVELS.SURFACE) {
                        const worldX = this.mouse.x + this.camera.x;
                        const worldY = this.mouse.y + this.camera.y;
                        const tileType = this.world.getTileAt(worldX, worldY, this.player.currentLevel);
                        const canUse = tileType === TILE_TYPES.GRASS;
                        
                        ctx.strokeStyle = canUse ? '#4af' : '#f44';
                        ctx.lineWidth = 2;
                        ctx.setLineDash([5, 5]);
                        ctx.strokeRect(
                            this.mouse.x - TILE_SIZE/2, 
                            this.mouse.y - TILE_SIZE/2, 
                            TILE_SIZE, 
                            TILE_SIZE
                        );
                        ctx.setLineDash([]);
                        
                        ctx.fillStyle = canUse ? '#4af' : '#f44';
                        ctx.font = '12px Courier New';
                        ctx.textAlign = 'center';
                        ctx.fillText('Лопата: создание шахты', this.mouse.x, this.mouse.y - 10);
                        
                        if (!canUse) {
                            ctx.fillText('Можно использовать только на траве!', this.mouse.x, this.mouse.y + TILE_SIZE + 15);
                        }
                    }
                    
                    // Прицел для кирки в пещере
                    else if (selectedItem.type === ITEM_TYPES.PICKAXE && this.player.currentLevel === WORLD_LEVELS.CAVE) {
                        const worldX = this.mouse.x + this.camera.x;
                        const worldY = this.mouse.y + this.camera.y;
                        const tileType = this.world.getTileAt(worldX, worldY, this.player.currentLevel);
                        const canUse = (tileType === CAVE_TILE_TYPES.CAVE_WALL || 
                                       tileType === CAVE_TILE_TYPES.IRON_ORE || 
                                       tileType === CAVE_TILE_TYPES.COAL_ORE) &&
                                       !this.player.isPositionInDarkness(worldX, worldY, this.world, this.gameTime);
                        
                        ctx.strokeStyle = canUse ? '#4af' : '#f44';
                        ctx.lineWidth = 2;
                        ctx.setLineDash([5, 5]);
                        ctx.strokeRect(
                            this.mouse.x - TILE_SIZE/2, 
                            this.mouse.y - TILE_SIZE/2, 
                            TILE_SIZE, 
                            TILE_SIZE
                        );
                        ctx.setLineDash([]);
                        
                        ctx.fillStyle = canUse ? '#4af' : '#f44';
                        ctx.font = '12px Courier New';
                        ctx.textAlign = 'center';
                        ctx.fillText('Кирка: добыча ресурсов', this.mouse.x, this.mouse.y - 10);
                        
                        if (!canUse) {
                            if (this.player.isPositionInDarkness(worldX, worldY, this.world, this.gameTime)) {
                                ctx.fillText('Слишком темно! Подойдите ближе или поставьте факел.', this.mouse.x, this.mouse.y + TILE_SIZE + 15);
                            } else {
                                ctx.fillText('Можно использовать только на стенах и рудах!', this.mouse.x, this.mouse.y + TILE_SIZE + 15);
                            }
                        }
                    }
                    
                    // Прицел для улучшенной кирки
                    else if (selectedItem.type === ITEM_TYPES.IMPROVED_PICKAXE) {
                        const worldX = this.mouse.x + this.camera.x;
                        const worldY = this.mouse.y + this.camera.y;
                        const tileX = Math.floor(worldX / TILE_SIZE);
                        const tileY = Math.floor(worldY / TILE_SIZE);
                        
                        let canUse = false;
                        let message = 'Улучшенная кирка: ';
                        
                        // Проверяем, есть ли алтарь для разрушения
                        const key = `${tileX},${tileY}`;
                        if (this.player.currentLevel === WORLD_LEVELS.SURFACE) {
                            if (this.world.surfacePlacedTiles.has(key)) {
                                const itemType = this.world.surfacePlacedTiles.get(key);
                                if (itemType === ITEM_TYPES.ALTAR || itemType === ITEM_TYPES.RESURRECTION_ALTAR) {
                                    canUse = true;
                                    message += 'разрушение алтаря';
                                }
                            }
                        } else if (this.player.currentLevel === WORLD_LEVELS.CAVE) {
                            if (this.world.cavePlacedTiles.has(key)) {
                                const itemType = this.world.cavePlacedTiles.get(key);
                                if (itemType === ITEM_TYPES.ALTAR || itemType === ITEM_TYPES.RESURRECTION_ALTAR) {
                                    canUse = true;
                                    message += 'разрушение алтаря';
                                }
                            } else {
                                // В пещере можно копать область 3x3
                                canUse = true;
                                message += 'добыча области 3x3';
                            }
                        }
                        
                        // Проверяем темноту для пещеры
                        if (this.player.currentLevel === WORLD_LEVELS.CAVE && 
                            this.player.isPositionInDarkness(worldX, worldY, this.world, this.gameTime)) {
                            canUse = false;
                        }
                        
                        // Рисуем область 3x3
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                const drawX = this.mouse.x + dx * TILE_SIZE - TILE_SIZE/2;
                                const drawY = this.mouse.y + dy * TILE_SIZE - TILE_SIZE/2;
                                
                                ctx.strokeStyle = canUse ? '#FFD700' : '#888';
                                ctx.lineWidth = 1;
                                ctx.setLineDash([3, 3]);
                                ctx.strokeRect(drawX, drawY, TILE_SIZE, TILE_SIZE);
                                ctx.setLineDash([]);
                            }
                        }
                        
                        // Основной прямоугольник в центре
                        ctx.strokeStyle = canUse ? '#FFD700' : '#888';
                        ctx.lineWidth = 2;
                        ctx.setLineDash([5, 5]);
                        ctx.strokeRect(
                            this.mouse.x - TILE_SIZE/2, 
                            this.mouse.y - TILE_SIZE/2, 
                            TILE_SIZE, 
                            TILE_SIZE
                        );
                        ctx.setLineDash([]);
                        
                        ctx.fillStyle = canUse ? '#FFD700' : '#888';
                        ctx.font = '12px Courier New';
                        ctx.textAlign = 'center';
                        ctx.fillText(message, this.mouse.x, this.mouse.y - 20);
                        
                        if (!canUse && this.player.currentLevel === WORLD_LEVELS.CAVE && 
                            this.player.isPositionInDarkness(worldX, worldY, this.world, this.gameTime)) {
                            ctx.fillText('Слишком темно! Подойдите ближе или поставьте факел.', this.mouse.x, this.mouse.y + TILE_SIZE + 15);
                        }
                    }
                    
                    // Прицел для магического скипетра
                    else if (selectedItem.type === ITEM_TYPES.MAGIC_SCEPTER) {
                        ctx.strokeStyle = '#9370DB';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(this.mouse.x, this.mouse.y, 10, 0, Math.PI * 2);
                        ctx.stroke();
                        
                        ctx.fillStyle = '#9370DB';
                        ctx.font = '12px Courier New';
                        ctx.textAlign = 'center';
                        ctx.fillText('Магический скипетр: выстрел снарядом', this.mouse.x, this.mouse.y - 15);
                    }
                    
                    // Проверяем, можно ли построить этот предмет
                    const placeableItems = [
                        ITEM_TYPES.WALL, ITEM_TYPES.ALTAR, ITEM_TYPES.FURNACE, 
                        ITEM_TYPES.LADDER, ITEM_TYPES.TORCH, ITEM_TYPES.RESURRECTION_ALTAR
                    ];
                    
                    if (placeableItems.includes(selectedItem.type)) {
                        // Проверяем, можно ли построить здесь
                        const worldX = this.mouse.x + this.camera.x;
                        const worldY = this.mouse.y + this.camera.y;
                        const tileX = Math.floor(worldX / TILE_SIZE);
                        const tileY = Math.floor(worldY / TILE_SIZE);
                        const key = `${tileX},${tileY}`;
                        
                        let canBuild = false;
                        if (tileX >= 0 && tileX < WORLD_WIDTH && tileY >= 0 && tileY < WORLD_HEIGHT) {
                            if (this.player.currentLevel === WORLD_LEVELS.SURFACE) {
                                if (this.world.surfaceTiles[tileY][tileX] !== TILE_TYPES.WATER && 
                                    !this.world.surfacePlacedTiles.has(key)) {
                                    canBuild = true;
                                }
                            } else {
                                if (this.world.caveTiles[tileY][tileX] === CAVE_TILE_TYPES.CAVE_FLOOR && 
                                    !this.world.cavePlacedTiles.has(key)) {
                                    canBuild = true;
                                }
                            }
                        }
                        
                        // Проверяем, не в темноте ли место (для пещеры и ночи на поверхности)
                        if ((this.player.currentLevel === WORLD_LEVELS.CAVE || 
                            (this.player.currentLevel === WORLD_LEVELS.SURFACE && 
                             this.gameTime.currentTime === TIME_OF_DAY.NIGHT)) && 
                            this.player.isPositionInDarkness(worldX, worldY, this.world, this.gameTime)) {
                            canBuild = false;
                        }
                        
                        // Проверяем расстояние до игрока
                        const playerCenterX = this.player.x + this.player.size / 2;
                        const playerCenterY = this.player.y + this.player.size / 2;
                        const distance = Math.sqrt(
                            Math.pow(worldX - playerCenterX, 2) + 
                            Math.pow(worldY - playerCenterY, 2)
                        );
                        
                        if (distance > TILE_SIZE * 5) {
                            canBuild = false;
                        }
                        
                        // Рисуем прицел
                        ctx.strokeStyle = canBuild ? '#4af' : '#f44';
                        ctx.lineWidth = 2;
                        ctx.setLineDash([5, 5]);
                        ctx.strokeRect(
                            this.mouse.x - TILE_SIZE/2, 
                            this.mouse.y - TILE_SIZE/2, 
                            TILE_SIZE, 
                            TILE_SIZE
                        );
                        ctx.setLineDash([]);
                        
                        // Подпись
                        ctx.fillStyle = canBuild ? '#4af' : '#f44';
                        ctx.font = '12px Courier New';
                        ctx.textAlign = 'center';
                        ctx.fillText(ITEM_NAMES[selectedItem.type], this.mouse.x, this.mouse.y - 10);
                        
                        // Если нельзя построить, показываем причину
                        if (!canBuild) {
                            if (distance > TILE_SIZE * 5) {
                                ctx.fillText('Слишком далеко!', this.mouse.x, this.mouse.y + TILE_SIZE + 15);
                            } else if ((this.player.currentLevel === WORLD_LEVELS.CAVE || 
                                      (this.player.currentLevel === WORLD_LEVELS.SURFACE && 
                                       this.gameTime.currentTime === TIME_OF_DAY.NIGHT)) && 
                                      this.player.isPositionInDarkness(worldX, worldY, this.world, this.gameTime)) {
                                ctx.fillText('Слишком темно! Поставьте факел.', this.mouse.x, this.mouse.y + TILE_SIZE + 15);
                            } else {
                                ctx.fillText('Нельзя построить здесь!', this.mouse.x, this.mouse.y + TILE_SIZE + 15);
                            }
                        }
                    } else if ((selectedItem.type === ITEM_TYPES.HAMMER || 
                              selectedItem.type === ITEM_TYPES.IRON_HAMMER)) {
                        // Прицел для атаки молотом
                        const worldX = this.mouse.x + this.camera.x;
                        const worldY = this.mouse.y + this.camera.y;
                        const attackRadius = 60;
                        
                        // Проверяем, есть ли враги в радиусе атаки
                        let canAttack = false;
                        let targetName = '';
                        
                        // Проверяем босса на поверхности
                        if (this.player.currentLevel === WORLD_LEVELS.SURFACE && this.boss && this.boss.alive) {
                            const dx = worldX - this.boss.x;
                            const dy = worldY - this.boss.y;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            
                            if (distance < 100) {
                                canAttack = true;
                                targetName = 'Босс';
                            }
                        }
                        
                        // Проверяем пещерного босса
                        if (this.player.currentLevel === WORLD_LEVELS.CAVE && this.caveBoss && this.caveBoss.alive) {
                            const dx = worldX - this.caveBoss.x;
                            const dy = worldY - this.caveBoss.y;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            
                            if (distance < 120) {
                                canAttack = true;
                                targetName = 'Пещерный босс';
                            }
                        }
                        
                        // Проверяем мобов
                        if (!canAttack) {
                            // Проверяем мобов на поверхности
                            if (this.player.currentLevel === WORLD_LEVELS.SURFACE) {
                                for (let zombie of this.gameTime.surfaceMobs) {
                                    if (zombie.alive) {
                                        const dx = worldX - zombie.x;
                                        const dy = worldY - zombie.y;
                                        const distance = Math.sqrt(dx * dx + dy * dy);
                                        
                                        if (distance < attackRadius) {
                                            canAttack = true;
                                            targetName = 'Зомби';
                                            break;
                                        }
                                    }
                                }
                            }
                            
                            // Проверяем мобов в пещере
                            if (this.player.currentLevel === WORLD_LEVELS.CAVE) {
                                for (let skeleton of this.gameTime.caveMobs) {
                                    if (skeleton.alive) {
                                        const dx = worldX - skeleton.x;
                                        const dy = worldY - skeleton.y;
                                        const distance = Math.sqrt(dx * dx + dy * dy);
                                        
                                        if (distance < attackRadius) {
                                            canAttack = true;
                                            targetName = 'Скелет';
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                        
                        // Если врагов нет, все равно можно атаковать (для разрушения чего-то в будущем)
                        if (!canAttack) {
                            canAttack = true;
                            targetName = 'Атака';
                        }
                        
                        this.ctx.strokeStyle = selectedItem.type === ITEM_TYPES.IRON_HAMMER ? 
                            (canAttack ? '#FFD700' : '#888') : 
                            (canAttack ? '#f44' : '#888');
                        this.ctx.lineWidth = 2;
                        this.ctx.beginPath();
                        this.ctx.arc(this.mouse.x, this.mouse.y, 15, 0, Math.PI * 2);
                        this.ctx.stroke();
                        
                        this.ctx.fillStyle = selectedItem.type === ITEM_TYPES.IRON_HAMMER ? 
                            (canAttack ? '#FFD700' : '#888') : 
                            (canAttack ? '#f44' : '#888');
                        this.ctx.font = '12px Courier New';
                        this.ctx.textAlign = 'center';
                        this.ctx.fillText(`${selectedItem.type === ITEM_TYPES.IRON_HAMMER ? 'Железный молот' : 'Молот'}: ${targetName}`, this.mouse.x, this.mouse.y - 25);
                    }
                }
                
                // Статусное сообщение
                if (this.statusTimer > 0) {
                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    this.ctx.fillRect(10, CANVAS_HEIGHT - 40, CANVAS_WIDTH - 20, 30);
                    
                    this.ctx.fillStyle = '#fff';
                    this.ctx.font = '16px Courier New';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText(this.statusMessage, CANVAS_WIDTH / 2, CANVAS_HEIGHT - 20);
                }
                
                // Отображаем информацию о точке возрождения
                this.drawRespawnInfo();
                
                // Отображаем информацию о мобах (только ночью)
                if (this.gameTime.currentTime === TIME_OF_DAY.NIGHT) {
                    this.drawMobInfo();
                }
            }
            
            drawRespawnInfo() {
                const infoX = CANVAS_WIDTH - 180;
                const infoY = 50;
                const infoWidth = 160;
                const infoHeight = 60;
                
                // Фон информации о точке возрождения
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                this.ctx.fillRect(infoX, infoY, infoWidth, infoHeight);
                
                this.ctx.fillStyle = '#00FF00';
                this.ctx.font = 'bold 14px Courier New';
                this.ctx.textAlign = 'left';
                this.ctx.fillText('Точка возрождения:', infoX + 10, infoY + 20);
                
                this.ctx.font = '12px Courier New';
                const respawnLevelText = this.player.respawnLevel === WORLD_LEVELS.SURFACE ? "Поверхность" : "Пещера";
                this.ctx.fillText(`Уровень: ${respawnLevelText}`, infoX + 10, infoY + 40);
            }
            
            drawMobInfo() {
                const infoX = 20;
                const infoY = CANVAS_HEIGHT - 120;
                const infoWidth = 200;
                const infoHeight = 50;
                
                // Фон информации о мобах
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                this.ctx.fillRect(infoX, infoY, infoWidth, infoHeight);
                
                this.ctx.fillStyle = '#fff';
                this.ctx.font = 'bold 14px Courier New';
                this.ctx.textAlign = 'left';
                this.ctx.fillText('Ночь! Враги активны:', infoX + 10, infoY + 20);
                
                this.ctx.font = '12px Courier New';
                
                // Мобы на поверхности
                if (this.player.currentLevel === WORLD_LEVELS.SURFACE) {
                    const zombieCount = this.gameTime.surfaceMobs.filter(mob => mob.alive).length;
                    this.ctx.fillStyle = zombieCount > 0 ? '#f44' : '#8f8';
                    this.ctx.fillText(`Зомби: ${zombieCount}`, infoX + 10, infoY + 40);
                }
                
                // Мобы в пещере
                if (this.player.currentLevel === WORLD_LEVELS.CAVE) {
                    const skeletonCount = this.gameTime.caveMobs.filter(mob => mob.alive).length;
                    this.ctx.fillStyle = skeletonCount > 0 ? '#f44' : '#8f8';
                    this.ctx.fillText(`Скелеты: ${skeletonCount}`, infoX + 10, infoY + 40);
                }
            }
            
            gameLoop(timestamp) {
                // Вычисляем deltaTime
                const deltaTime = timestamp - this.lastTime || 0;
                this.lastTime = timestamp;
                
                // Обновляем и рисуем игру
                this.update(deltaTime);
                this.draw();
                
                // Продолжаем игровой цикл
                requestAnimationFrame(this.gameLoop.bind(this));
            }
        }
        
        // ============================
        // ЗАПУСК ИГРЫ
        // ============================
        // Ждем загрузки DOM
        document.addEventListener('DOMContentLoaded', () => {
            // Создаем и запускаем игру
            window.game = new Game();
        });
    </script>
</body>
</html>